/*
 * Copyright (c) 2014, Freescale Semiconductor, Inc.
 * All rights reserved.
 *
 * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL FREESCALE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */
/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_RTC_REGISTERS_H__
#define __HW_RTC_REGISTERS_H__

#include "regs.h"

/*
 * MKL46Z4 RTC
 *
 * Secure Real Time Clock
 *
 * Registers defined in this header file:
 * - HW_RTC_TSR - RTC Time Seconds Register
 * - HW_RTC_TPR - RTC Time Prescaler Register
 * - HW_RTC_TAR - RTC Time Alarm Register
 * - HW_RTC_TCR - RTC Time Compensation Register
 * - HW_RTC_CR - RTC Control Register
 * - HW_RTC_SR - RTC Status Register
 * - HW_RTC_LR - RTC Lock Register
 * - HW_RTC_IER - RTC Interrupt Enable Register
 *
 * - hw_rtc_t - Struct containing all module registers.
 */

//! @name Module base addresses
//@{
#ifndef REGS_RTC_BASE
#define HW_RTC_INSTANCE_COUNT (1U) //!< Number of instances of the RTC module.
#define REGS_RTC_BASE (0x4003D000U) //!< Base address for RTC.
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_RTC_TSR - RTC Time Seconds Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_RTC_TSR - RTC Time Seconds Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_rtc_tsr
{
    uint32_t U;
    struct _hw_rtc_tsr_bitfields
    {
        uint32_t TSR : 32;             //!< [31:0] Time Seconds Register
    } B;
} hw_rtc_tsr_t;
#endif

/*!
 * @name Constants and macros for entire RTC_TSR register
 */
//@{
#define HW_RTC_TSR_ADDR          (REGS_RTC_BASE + 0x0U)

#ifndef __LANGUAGE_ASM__
#define HW_RTC_TSR               (*(__IO hw_rtc_tsr_t *) HW_RTC_TSR_ADDR)
#define HW_RTC_TSR_RD()          (HW_RTC_TSR.U)
#define HW_RTC_TSR_WR(v)         (HW_RTC_TSR.U = (v))
#define HW_RTC_TSR_SET(v)        (BME_OR32(HW_RTC_TSR_ADDR, (uint32_t)(v)))
#define HW_RTC_TSR_CLR(v)        (BME_AND32(HW_RTC_TSR_ADDR, (uint32_t)(~(v))))
#define HW_RTC_TSR_TOG(v)        (BME_XOR32(HW_RTC_TSR_ADDR, (uint32_t)(v)))
#endif
//@}

/*
 * Constants & macros for individual RTC_TSR bitfields
 */

/*!
 * @name Register RTC_TSR, field TSR[31:0] (RW)
 *
 * When the time counter is enabled, the TSR is read only and increments once a
 * second provided SR[TOF] or SR[TIF] are not set. The time counter will read as
 * zero when SR[TOF] or SR[TIF] are set. When the time counter is disabled, the
 * TSR can be read or written. Writing to the TSR when the time counter is
 * disabled will clear the SR[TOF] and/or the SR[TIF]. Writing to TSR with zero is
 * supported, but not recommended because TSR will read as zero when SR[TIF] or
 * SR[TOF] are set (indicating the time is invalid).
 */
//@{
#define BP_RTC_TSR_TSR       (0U)          //!< Bit position for RTC_TSR_TSR.
#define BM_RTC_TSR_TSR       (0xFFFFFFFFU) //!< Bit mask for RTC_TSR_TSR.
#define BS_RTC_TSR_TSR       (32U)         //!< Bit field size in bits for RTC_TSR_TSR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_TSR_TSR field.
#define BR_RTC_TSR_TSR       (BME_UBFX32(HW_RTC_TSR_ADDR, BP_RTC_TSR_TSR, BS_RTC_TSR_TSR))
#endif

//! @brief Format value for bitfield RTC_TSR_TSR.
#define BF_RTC_TSR_TSR(v)    (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_TSR_TSR), uint32_t) & BM_RTC_TSR_TSR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TSR field to a new value.
#define BW_RTC_TSR_TSR(v)    (BME_BFI32(HW_RTC_TSR_ADDR, ((uint32_t)(v) << BP_RTC_TSR_TSR), BP_RTC_TSR_TSR, 32))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_RTC_TPR - RTC Time Prescaler Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_RTC_TPR - RTC Time Prescaler Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_rtc_tpr
{
    uint32_t U;
    struct _hw_rtc_tpr_bitfields
    {
        uint32_t TPR : 16;             //!< [15:0] Time Prescaler Register
        uint32_t RESERVED0 : 16;       //!< [31:16]
    } B;
} hw_rtc_tpr_t;
#endif

/*!
 * @name Constants and macros for entire RTC_TPR register
 */
//@{
#define HW_RTC_TPR_ADDR          (REGS_RTC_BASE + 0x4U)

#ifndef __LANGUAGE_ASM__
#define HW_RTC_TPR               (*(__IO hw_rtc_tpr_t *) HW_RTC_TPR_ADDR)
#define HW_RTC_TPR_RD()          (HW_RTC_TPR.U)
#define HW_RTC_TPR_WR(v)         (HW_RTC_TPR.U = (v))
#define HW_RTC_TPR_SET(v)        (BME_OR32(HW_RTC_TPR_ADDR, (uint32_t)(v)))
#define HW_RTC_TPR_CLR(v)        (BME_AND32(HW_RTC_TPR_ADDR, (uint32_t)(~(v))))
#define HW_RTC_TPR_TOG(v)        (BME_XOR32(HW_RTC_TPR_ADDR, (uint32_t)(v)))
#endif
//@}

/*
 * Constants & macros for individual RTC_TPR bitfields
 */

/*!
 * @name Register RTC_TPR, field TPR[15:0] (RW)
 *
 * When the time counter is enabled, the TPR is read only and increments every
 * 32.768 kHz clock cycle. The time counter will read as zero when SR[TOF] or
 * SR[TIF] are set. When the time counter is disabled, the TPR can be read or
 * written. The TSR[TSR] increments when bit 14 of the TPR transitions from a logic one
 * to a logic zero.
 */
//@{
#define BP_RTC_TPR_TPR       (0U)          //!< Bit position for RTC_TPR_TPR.
#define BM_RTC_TPR_TPR       (0x0000FFFFU) //!< Bit mask for RTC_TPR_TPR.
#define BS_RTC_TPR_TPR       (16U)         //!< Bit field size in bits for RTC_TPR_TPR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_TPR_TPR field.
#define BR_RTC_TPR_TPR       (BME_UBFX32(HW_RTC_TPR_ADDR, BP_RTC_TPR_TPR, BS_RTC_TPR_TPR))
#endif

//! @brief Format value for bitfield RTC_TPR_TPR.
#define BF_RTC_TPR_TPR(v)    (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_TPR_TPR), uint32_t) & BM_RTC_TPR_TPR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TPR field to a new value.
#define BW_RTC_TPR_TPR(v)    (BME_BFI32(HW_RTC_TPR_ADDR, ((uint32_t)(v) << BP_RTC_TPR_TPR), BP_RTC_TPR_TPR, 16))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_RTC_TAR - RTC Time Alarm Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_RTC_TAR - RTC Time Alarm Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_rtc_tar
{
    uint32_t U;
    struct _hw_rtc_tar_bitfields
    {
        uint32_t TAR : 32;             //!< [31:0] Time Alarm Register
    } B;
} hw_rtc_tar_t;
#endif

/*!
 * @name Constants and macros for entire RTC_TAR register
 */
//@{
#define HW_RTC_TAR_ADDR          (REGS_RTC_BASE + 0x8U)

#ifndef __LANGUAGE_ASM__
#define HW_RTC_TAR               (*(__IO hw_rtc_tar_t *) HW_RTC_TAR_ADDR)
#define HW_RTC_TAR_RD()          (HW_RTC_TAR.U)
#define HW_RTC_TAR_WR(v)         (HW_RTC_TAR.U = (v))
#define HW_RTC_TAR_SET(v)        (BME_OR32(HW_RTC_TAR_ADDR, (uint32_t)(v)))
#define HW_RTC_TAR_CLR(v)        (BME_AND32(HW_RTC_TAR_ADDR, (uint32_t)(~(v))))
#define HW_RTC_TAR_TOG(v)        (BME_XOR32(HW_RTC_TAR_ADDR, (uint32_t)(v)))
#endif
//@}

/*
 * Constants & macros for individual RTC_TAR bitfields
 */

/*!
 * @name Register RTC_TAR, field TAR[31:0] (RW)
 *
 * When the time counter is enabled, the SR[TAF] is set whenever the TAR[TAR]
 * equals the TSR[TSR] and the TSR[TSR] increments. Writing to the TAR clears the
 * SR[TAF].
 */
//@{
#define BP_RTC_TAR_TAR       (0U)          //!< Bit position for RTC_TAR_TAR.
#define BM_RTC_TAR_TAR       (0xFFFFFFFFU) //!< Bit mask for RTC_TAR_TAR.
#define BS_RTC_TAR_TAR       (32U)         //!< Bit field size in bits for RTC_TAR_TAR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_TAR_TAR field.
#define BR_RTC_TAR_TAR       (BME_UBFX32(HW_RTC_TAR_ADDR, BP_RTC_TAR_TAR, BS_RTC_TAR_TAR))
#endif

//! @brief Format value for bitfield RTC_TAR_TAR.
#define BF_RTC_TAR_TAR(v)    (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_TAR_TAR), uint32_t) & BM_RTC_TAR_TAR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TAR field to a new value.
#define BW_RTC_TAR_TAR(v)    (BME_BFI32(HW_RTC_TAR_ADDR, ((uint32_t)(v) << BP_RTC_TAR_TAR), BP_RTC_TAR_TAR, 32))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_RTC_TCR - RTC Time Compensation Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_RTC_TCR - RTC Time Compensation Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_rtc_tcr
{
    uint32_t U;
    struct _hw_rtc_tcr_bitfields
    {
        uint32_t TCR : 8;              //!< [7:0] Time Compensation Register
        uint32_t CIR : 8;              //!< [15:8] Compensation Interval Register
        uint32_t TCV : 8;              //!< [23:16] Time Compensation Value
        uint32_t CIC : 8;              //!< [31:24] Compensation Interval Counter
    } B;
} hw_rtc_tcr_t;
#endif

/*!
 * @name Constants and macros for entire RTC_TCR register
 */
//@{
#define HW_RTC_TCR_ADDR          (REGS_RTC_BASE + 0xCU)

#ifndef __LANGUAGE_ASM__
#define HW_RTC_TCR               (*(__IO hw_rtc_tcr_t *) HW_RTC_TCR_ADDR)
#define HW_RTC_TCR_RD()          (HW_RTC_TCR.U)
#define HW_RTC_TCR_WR(v)         (HW_RTC_TCR.U = (v))
#define HW_RTC_TCR_SET(v)        (BME_OR32(HW_RTC_TCR_ADDR, (uint32_t)(v)))
#define HW_RTC_TCR_CLR(v)        (BME_AND32(HW_RTC_TCR_ADDR, (uint32_t)(~(v))))
#define HW_RTC_TCR_TOG(v)        (BME_XOR32(HW_RTC_TCR_ADDR, (uint32_t)(v)))
#endif
//@}

/*
 * Constants & macros for individual RTC_TCR bitfields
 */

/*!
 * @name Register RTC_TCR, field TCR[7:0] (RW)
 *
 * Configures the number of 32.768 kHz clock cycles in each second. This
 * register is double buffered and writes do not take affect until the end of the
 * current compensation interval.
 *
 * Values:
 * - 10000000 - Time Prescaler Register overflows every 32896 clock cycles.
 * - 11111111 - Time Prescaler Register overflows every 32769 clock cycles.
 * - 0 - Time Prescaler Register overflows every 32768 clock cycles.
 * - 1 - Time Prescaler Register overflows every 32767 clock cycles.
 * - 1111111 - Time Prescaler Register overflows every 32641 clock cycles.
 */
//@{
#define BP_RTC_TCR_TCR       (0U)          //!< Bit position for RTC_TCR_TCR.
#define BM_RTC_TCR_TCR       (0x000000FFU) //!< Bit mask for RTC_TCR_TCR.
#define BS_RTC_TCR_TCR       (8U)          //!< Bit field size in bits for RTC_TCR_TCR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_TCR_TCR field.
#define BR_RTC_TCR_TCR       (BME_UBFX32(HW_RTC_TCR_ADDR, BP_RTC_TCR_TCR, BS_RTC_TCR_TCR))
#endif

//! @brief Format value for bitfield RTC_TCR_TCR.
#define BF_RTC_TCR_TCR(v)    (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_TCR_TCR), uint32_t) & BM_RTC_TCR_TCR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TCR field to a new value.
#define BW_RTC_TCR_TCR(v)    (BME_BFI32(HW_RTC_TCR_ADDR, ((uint32_t)(v) << BP_RTC_TCR_TCR), BP_RTC_TCR_TCR, 8))
#endif
//@}

/*!
 * @name Register RTC_TCR, field CIR[15:8] (RW)
 *
 * Configures the compensation interval in seconds from 1 to 256 to control how
 * frequently the TCR should adjust the number of 32.768 kHz cycles in each
 * second. The value written should be one less than the number of seconds. For
 * example, write zero to configure for a compensation interval of one second. This
 * register is double buffered and writes do not take affect until the end of the
 * current compensation interval.
 */
//@{
#define BP_RTC_TCR_CIR       (8U)          //!< Bit position for RTC_TCR_CIR.
#define BM_RTC_TCR_CIR       (0x0000FF00U) //!< Bit mask for RTC_TCR_CIR.
#define BS_RTC_TCR_CIR       (8U)          //!< Bit field size in bits for RTC_TCR_CIR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_TCR_CIR field.
#define BR_RTC_TCR_CIR       (BME_UBFX32(HW_RTC_TCR_ADDR, BP_RTC_TCR_CIR, BS_RTC_TCR_CIR))
#endif

//! @brief Format value for bitfield RTC_TCR_CIR.
#define BF_RTC_TCR_CIR(v)    (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_TCR_CIR), uint32_t) & BM_RTC_TCR_CIR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CIR field to a new value.
#define BW_RTC_TCR_CIR(v)    (BME_BFI32(HW_RTC_TCR_ADDR, ((uint32_t)(v) << BP_RTC_TCR_CIR), BP_RTC_TCR_CIR, 8))
#endif
//@}

/*!
 * @name Register RTC_TCR, field TCV[23:16] (RO)
 *
 * Current value used by the compensation logic for the present second interval.
 * Updated once a second if the CIC equals 0 with the contents of the TCR field.
 * If the CIC does not equal zero then it is loaded with zero (compensation is
 * not enabled for that second increment).
 */
//@{
#define BP_RTC_TCR_TCV       (16U)         //!< Bit position for RTC_TCR_TCV.
#define BM_RTC_TCR_TCV       (0x00FF0000U) //!< Bit mask for RTC_TCR_TCV.
#define BS_RTC_TCR_TCV       (8U)          //!< Bit field size in bits for RTC_TCR_TCV.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_TCR_TCV field.
#define BR_RTC_TCR_TCV       (BME_UBFX32(HW_RTC_TCR_ADDR, BP_RTC_TCR_TCV, BS_RTC_TCR_TCV))
#endif
//@}

/*!
 * @name Register RTC_TCR, field CIC[31:24] (RO)
 *
 * Current value of the compensation interval counter. If the compensation
 * interval counter equals zero then it is loaded with the contents of the CIR. If the
 * CIC does not equal zero then it is decremented once a second.
 */
//@{
#define BP_RTC_TCR_CIC       (24U)         //!< Bit position for RTC_TCR_CIC.
#define BM_RTC_TCR_CIC       (0xFF000000U) //!< Bit mask for RTC_TCR_CIC.
#define BS_RTC_TCR_CIC       (8U)          //!< Bit field size in bits for RTC_TCR_CIC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_TCR_CIC field.
#define BR_RTC_TCR_CIC       (BME_UBFX32(HW_RTC_TCR_ADDR, BP_RTC_TCR_CIC, BS_RTC_TCR_CIC))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_RTC_CR - RTC Control Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_RTC_CR - RTC Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_rtc_cr
{
    uint32_t U;
    struct _hw_rtc_cr_bitfields
    {
        uint32_t SWR : 1;              //!< [0] Software Reset
        uint32_t WPE : 1;              //!< [1] Wakeup Pin Enable
        uint32_t SUP : 1;              //!< [2] Supervisor Access
        uint32_t UM : 1;               //!< [3] Update Mode
        uint32_t RESERVED0 : 4;        //!< [7:4]
        uint32_t OSCE : 1;             //!< [8] Oscillator Enable
        uint32_t CLKO : 1;             //!< [9] Clock Output
        uint32_t SC16P : 1;            //!< [10] Oscillator 16pF Load Configure
        uint32_t SC8P : 1;             //!< [11] Oscillator 8pF Load Configure
        uint32_t SC4P : 1;             //!< [12] Oscillator 4pF Load Configure
        uint32_t SC2P : 1;             //!< [13] Oscillator 2pF Load Configure
        uint32_t RESERVED1 : 18;       //!< [31:14]
    } B;
} hw_rtc_cr_t;
#endif

/*!
 * @name Constants and macros for entire RTC_CR register
 */
//@{
#define HW_RTC_CR_ADDR           (REGS_RTC_BASE + 0x10U)

#ifndef __LANGUAGE_ASM__
#define HW_RTC_CR                (*(__IO hw_rtc_cr_t *) HW_RTC_CR_ADDR)
#define HW_RTC_CR_RD()           (HW_RTC_CR.U)
#define HW_RTC_CR_WR(v)          (HW_RTC_CR.U = (v))
#define HW_RTC_CR_SET(v)         (BME_OR32(HW_RTC_CR_ADDR, (uint32_t)(v)))
#define HW_RTC_CR_CLR(v)         (BME_AND32(HW_RTC_CR_ADDR, (uint32_t)(~(v))))
#define HW_RTC_CR_TOG(v)         (BME_XOR32(HW_RTC_CR_ADDR, (uint32_t)(v)))
#endif
//@}

/*
 * Constants & macros for individual RTC_CR bitfields
 */

/*!
 * @name Register RTC_CR, field SWR[0] (RW)
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Resets all RTC registers except for the SWR bit . The SWR bit is
 *     cleared by POR and by software explicitly clearing it.
 */
//@{
#define BP_RTC_CR_SWR        (0U)          //!< Bit position for RTC_CR_SWR.
#define BM_RTC_CR_SWR        (0x00000001U) //!< Bit mask for RTC_CR_SWR.
#define BS_RTC_CR_SWR        (1U)          //!< Bit field size in bits for RTC_CR_SWR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_CR_SWR field.
#define BR_RTC_CR_SWR        (BME_UBFX32(HW_RTC_CR_ADDR, BP_RTC_CR_SWR, BS_RTC_CR_SWR))
#endif

//! @brief Format value for bitfield RTC_CR_SWR.
#define BF_RTC_CR_SWR(v)     (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_CR_SWR), uint32_t) & BM_RTC_CR_SWR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SWR field to a new value.
#define BW_RTC_CR_SWR(v)     (BME_BFI32(HW_RTC_CR_ADDR, ((uint32_t)(v) << BP_RTC_CR_SWR), BP_RTC_CR_SWR, 1))
#endif
//@}

/*!
 * @name Register RTC_CR, field WPE[1] (RW)
 *
 * The wakeup pin is optional and not available on all devices.
 *
 * Values:
 * - 0 - Wakeup pin is disabled.
 * - 1 - Wakeup pin is enabled and wakeup pin asserts if the RTC interrupt
 *     asserts or the wakeup pin is turned on.
 */
//@{
#define BP_RTC_CR_WPE        (1U)          //!< Bit position for RTC_CR_WPE.
#define BM_RTC_CR_WPE        (0x00000002U) //!< Bit mask for RTC_CR_WPE.
#define BS_RTC_CR_WPE        (1U)          //!< Bit field size in bits for RTC_CR_WPE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_CR_WPE field.
#define BR_RTC_CR_WPE        (BME_UBFX32(HW_RTC_CR_ADDR, BP_RTC_CR_WPE, BS_RTC_CR_WPE))
#endif

//! @brief Format value for bitfield RTC_CR_WPE.
#define BF_RTC_CR_WPE(v)     (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_CR_WPE), uint32_t) & BM_RTC_CR_WPE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the WPE field to a new value.
#define BW_RTC_CR_WPE(v)     (BME_BFI32(HW_RTC_CR_ADDR, ((uint32_t)(v) << BP_RTC_CR_WPE), BP_RTC_CR_WPE, 1))
#endif
//@}

/*!
 * @name Register RTC_CR, field SUP[2] (RW)
 *
 * Values:
 * - 0 - Non-supervisor mode write accesses are not supported and generate a bus
 *     error.
 * - 1 - Non-supervisor mode write accesses are supported.
 */
//@{
#define BP_RTC_CR_SUP        (2U)          //!< Bit position for RTC_CR_SUP.
#define BM_RTC_CR_SUP        (0x00000004U) //!< Bit mask for RTC_CR_SUP.
#define BS_RTC_CR_SUP        (1U)          //!< Bit field size in bits for RTC_CR_SUP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_CR_SUP field.
#define BR_RTC_CR_SUP        (BME_UBFX32(HW_RTC_CR_ADDR, BP_RTC_CR_SUP, BS_RTC_CR_SUP))
#endif

//! @brief Format value for bitfield RTC_CR_SUP.
#define BF_RTC_CR_SUP(v)     (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_CR_SUP), uint32_t) & BM_RTC_CR_SUP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUP field to a new value.
#define BW_RTC_CR_SUP(v)     (BME_BFI32(HW_RTC_CR_ADDR, ((uint32_t)(v) << BP_RTC_CR_SUP), BP_RTC_CR_SUP, 1))
#endif
//@}

/*!
 * @name Register RTC_CR, field UM[3] (RW)
 *
 * Allows SR[TCE] to be written even when the Status Register is locked. When
 * set, the SR[TCE] can always be written if the SR[TIF] or SR[TOF] are set or if
 * the SR[TCE] is clear.
 *
 * Values:
 * - 0 - Registers cannot be written when locked.
 * - 1 - Registers can be written when locked under limited conditions.
 */
//@{
#define BP_RTC_CR_UM         (3U)          //!< Bit position for RTC_CR_UM.
#define BM_RTC_CR_UM         (0x00000008U) //!< Bit mask for RTC_CR_UM.
#define BS_RTC_CR_UM         (1U)          //!< Bit field size in bits for RTC_CR_UM.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_CR_UM field.
#define BR_RTC_CR_UM         (BME_UBFX32(HW_RTC_CR_ADDR, BP_RTC_CR_UM, BS_RTC_CR_UM))
#endif

//! @brief Format value for bitfield RTC_CR_UM.
#define BF_RTC_CR_UM(v)      (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_CR_UM), uint32_t) & BM_RTC_CR_UM)

#ifndef __LANGUAGE_ASM__
//! @brief Set the UM field to a new value.
#define BW_RTC_CR_UM(v)      (BME_BFI32(HW_RTC_CR_ADDR, ((uint32_t)(v) << BP_RTC_CR_UM), BP_RTC_CR_UM, 1))
#endif
//@}

/*!
 * @name Register RTC_CR, field OSCE[8] (RW)
 *
 * Values:
 * - 0 - 32.768 kHz oscillator is disabled.
 * - 1 - 32.768 kHz oscillator is enabled. After setting this bit, wait the
 *     oscillator startup time before enabling the time counter to allow the 32.768
 *     kHz clock time to stabilize.
 */
//@{
#define BP_RTC_CR_OSCE       (8U)          //!< Bit position for RTC_CR_OSCE.
#define BM_RTC_CR_OSCE       (0x00000100U) //!< Bit mask for RTC_CR_OSCE.
#define BS_RTC_CR_OSCE       (1U)          //!< Bit field size in bits for RTC_CR_OSCE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_CR_OSCE field.
#define BR_RTC_CR_OSCE       (BME_UBFX32(HW_RTC_CR_ADDR, BP_RTC_CR_OSCE, BS_RTC_CR_OSCE))
#endif

//! @brief Format value for bitfield RTC_CR_OSCE.
#define BF_RTC_CR_OSCE(v)    (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_CR_OSCE), uint32_t) & BM_RTC_CR_OSCE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the OSCE field to a new value.
#define BW_RTC_CR_OSCE(v)    (BME_BFI32(HW_RTC_CR_ADDR, ((uint32_t)(v) << BP_RTC_CR_OSCE), BP_RTC_CR_OSCE, 1))
#endif
//@}

/*!
 * @name Register RTC_CR, field CLKO[9] (RW)
 *
 * Values:
 * - 0 - The 32 kHz clock is output to other peripherals.
 * - 1 - The 32 kHz clock is not output to other peripherals.
 */
//@{
#define BP_RTC_CR_CLKO       (9U)          //!< Bit position for RTC_CR_CLKO.
#define BM_RTC_CR_CLKO       (0x00000200U) //!< Bit mask for RTC_CR_CLKO.
#define BS_RTC_CR_CLKO       (1U)          //!< Bit field size in bits for RTC_CR_CLKO.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_CR_CLKO field.
#define BR_RTC_CR_CLKO       (BME_UBFX32(HW_RTC_CR_ADDR, BP_RTC_CR_CLKO, BS_RTC_CR_CLKO))
#endif

//! @brief Format value for bitfield RTC_CR_CLKO.
#define BF_RTC_CR_CLKO(v)    (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_CR_CLKO), uint32_t) & BM_RTC_CR_CLKO)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CLKO field to a new value.
#define BW_RTC_CR_CLKO(v)    (BME_BFI32(HW_RTC_CR_ADDR, ((uint32_t)(v) << BP_RTC_CR_CLKO), BP_RTC_CR_CLKO, 1))
#endif
//@}

/*!
 * @name Register RTC_CR, field SC16P[10] (RW)
 *
 * Values:
 * - 0 - Disable the load.
 * - 1 - Enable the additional load.
 */
//@{
#define BP_RTC_CR_SC16P      (10U)         //!< Bit position for RTC_CR_SC16P.
#define BM_RTC_CR_SC16P      (0x00000400U) //!< Bit mask for RTC_CR_SC16P.
#define BS_RTC_CR_SC16P      (1U)          //!< Bit field size in bits for RTC_CR_SC16P.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_CR_SC16P field.
#define BR_RTC_CR_SC16P      (BME_UBFX32(HW_RTC_CR_ADDR, BP_RTC_CR_SC16P, BS_RTC_CR_SC16P))
#endif

//! @brief Format value for bitfield RTC_CR_SC16P.
#define BF_RTC_CR_SC16P(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_CR_SC16P), uint32_t) & BM_RTC_CR_SC16P)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SC16P field to a new value.
#define BW_RTC_CR_SC16P(v)   (BME_BFI32(HW_RTC_CR_ADDR, ((uint32_t)(v) << BP_RTC_CR_SC16P), BP_RTC_CR_SC16P, 1))
#endif
//@}

/*!
 * @name Register RTC_CR, field SC8P[11] (RW)
 *
 * Values:
 * - 0 - Disable the load.
 * - 1 - Enable the additional load.
 */
//@{
#define BP_RTC_CR_SC8P       (11U)         //!< Bit position for RTC_CR_SC8P.
#define BM_RTC_CR_SC8P       (0x00000800U) //!< Bit mask for RTC_CR_SC8P.
#define BS_RTC_CR_SC8P       (1U)          //!< Bit field size in bits for RTC_CR_SC8P.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_CR_SC8P field.
#define BR_RTC_CR_SC8P       (BME_UBFX32(HW_RTC_CR_ADDR, BP_RTC_CR_SC8P, BS_RTC_CR_SC8P))
#endif

//! @brief Format value for bitfield RTC_CR_SC8P.
#define BF_RTC_CR_SC8P(v)    (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_CR_SC8P), uint32_t) & BM_RTC_CR_SC8P)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SC8P field to a new value.
#define BW_RTC_CR_SC8P(v)    (BME_BFI32(HW_RTC_CR_ADDR, ((uint32_t)(v) << BP_RTC_CR_SC8P), BP_RTC_CR_SC8P, 1))
#endif
//@}

/*!
 * @name Register RTC_CR, field SC4P[12] (RW)
 *
 * Values:
 * - 0 - Disable the load.
 * - 1 - Enable the additional load.
 */
//@{
#define BP_RTC_CR_SC4P       (12U)         //!< Bit position for RTC_CR_SC4P.
#define BM_RTC_CR_SC4P       (0x00001000U) //!< Bit mask for RTC_CR_SC4P.
#define BS_RTC_CR_SC4P       (1U)          //!< Bit field size in bits for RTC_CR_SC4P.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_CR_SC4P field.
#define BR_RTC_CR_SC4P       (BME_UBFX32(HW_RTC_CR_ADDR, BP_RTC_CR_SC4P, BS_RTC_CR_SC4P))
#endif

//! @brief Format value for bitfield RTC_CR_SC4P.
#define BF_RTC_CR_SC4P(v)    (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_CR_SC4P), uint32_t) & BM_RTC_CR_SC4P)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SC4P field to a new value.
#define BW_RTC_CR_SC4P(v)    (BME_BFI32(HW_RTC_CR_ADDR, ((uint32_t)(v) << BP_RTC_CR_SC4P), BP_RTC_CR_SC4P, 1))
#endif
//@}

/*!
 * @name Register RTC_CR, field SC2P[13] (RW)
 *
 * Values:
 * - 0 - Disable the load.
 * - 1 - Enable the additional load.
 */
//@{
#define BP_RTC_CR_SC2P       (13U)         //!< Bit position for RTC_CR_SC2P.
#define BM_RTC_CR_SC2P       (0x00002000U) //!< Bit mask for RTC_CR_SC2P.
#define BS_RTC_CR_SC2P       (1U)          //!< Bit field size in bits for RTC_CR_SC2P.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_CR_SC2P field.
#define BR_RTC_CR_SC2P       (BME_UBFX32(HW_RTC_CR_ADDR, BP_RTC_CR_SC2P, BS_RTC_CR_SC2P))
#endif

//! @brief Format value for bitfield RTC_CR_SC2P.
#define BF_RTC_CR_SC2P(v)    (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_CR_SC2P), uint32_t) & BM_RTC_CR_SC2P)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SC2P field to a new value.
#define BW_RTC_CR_SC2P(v)    (BME_BFI32(HW_RTC_CR_ADDR, ((uint32_t)(v) << BP_RTC_CR_SC2P), BP_RTC_CR_SC2P, 1))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_RTC_SR - RTC Status Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_RTC_SR - RTC Status Register (RW)
 *
 * Reset value: 0x00000001U
 */
typedef union _hw_rtc_sr
{
    uint32_t U;
    struct _hw_rtc_sr_bitfields
    {
        uint32_t TIF : 1;              //!< [0] Time Invalid Flag
        uint32_t TOF : 1;              //!< [1] Time Overflow Flag
        uint32_t TAF : 1;              //!< [2] Time Alarm Flag
        uint32_t RESERVED0 : 1;        //!< [3]
        uint32_t TCE : 1;              //!< [4] Time Counter Enable
        uint32_t RESERVED1 : 27;       //!< [31:5]
    } B;
} hw_rtc_sr_t;
#endif

/*!
 * @name Constants and macros for entire RTC_SR register
 */
//@{
#define HW_RTC_SR_ADDR           (REGS_RTC_BASE + 0x14U)

#ifndef __LANGUAGE_ASM__
#define HW_RTC_SR                (*(__IO hw_rtc_sr_t *) HW_RTC_SR_ADDR)
#define HW_RTC_SR_RD()           (HW_RTC_SR.U)
#define HW_RTC_SR_WR(v)          (HW_RTC_SR.U = (v))
#define HW_RTC_SR_SET(v)         (BME_OR32(HW_RTC_SR_ADDR, (uint32_t)(v)))
#define HW_RTC_SR_CLR(v)         (BME_AND32(HW_RTC_SR_ADDR, (uint32_t)(~(v))))
#define HW_RTC_SR_TOG(v)         (BME_XOR32(HW_RTC_SR_ADDR, (uint32_t)(v)))
#endif
//@}

/*
 * Constants & macros for individual RTC_SR bitfields
 */

/*!
 * @name Register RTC_SR, field TIF[0] (RO)
 *
 * The time invalid flag is set on POR or software reset. The TSR and TPR do not
 * increment and read as zero when this bit is set. This bit is cleared by
 * writing the TSR register when the time counter is disabled.
 *
 * Values:
 * - 0 - Time is valid.
 * - 1 - Time is invalid and time counter is read as zero.
 */
//@{
#define BP_RTC_SR_TIF        (0U)          //!< Bit position for RTC_SR_TIF.
#define BM_RTC_SR_TIF        (0x00000001U) //!< Bit mask for RTC_SR_TIF.
#define BS_RTC_SR_TIF        (1U)          //!< Bit field size in bits for RTC_SR_TIF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_SR_TIF field.
#define BR_RTC_SR_TIF        (BME_UBFX32(HW_RTC_SR_ADDR, BP_RTC_SR_TIF, BS_RTC_SR_TIF))
#endif
//@}

/*!
 * @name Register RTC_SR, field TOF[1] (RO)
 *
 * Time overflow flag is set when the time counter is enabled and overflows. The
 * TSR and TPR do not increment and read as zero when this bit is set. This bit
 * is cleared by writing the TSR register when the time counter is disabled.
 *
 * Values:
 * - 0 - Time overflow has not occurred.
 * - 1 - Time overflow has occurred and time counter is read as zero.
 */
//@{
#define BP_RTC_SR_TOF        (1U)          //!< Bit position for RTC_SR_TOF.
#define BM_RTC_SR_TOF        (0x00000002U) //!< Bit mask for RTC_SR_TOF.
#define BS_RTC_SR_TOF        (1U)          //!< Bit field size in bits for RTC_SR_TOF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_SR_TOF field.
#define BR_RTC_SR_TOF        (BME_UBFX32(HW_RTC_SR_ADDR, BP_RTC_SR_TOF, BS_RTC_SR_TOF))
#endif
//@}

/*!
 * @name Register RTC_SR, field TAF[2] (RO)
 *
 * Time alarm flag is set when the TAR[TAR] equals the TSR[TSR] and the TSR[TSR]
 * increments. This bit is cleared by writing the TAR register.
 *
 * Values:
 * - 0 - Time alarm has not occurred.
 * - 1 - Time alarm has occurred.
 */
//@{
#define BP_RTC_SR_TAF        (2U)          //!< Bit position for RTC_SR_TAF.
#define BM_RTC_SR_TAF        (0x00000004U) //!< Bit mask for RTC_SR_TAF.
#define BS_RTC_SR_TAF        (1U)          //!< Bit field size in bits for RTC_SR_TAF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_SR_TAF field.
#define BR_RTC_SR_TAF        (BME_UBFX32(HW_RTC_SR_ADDR, BP_RTC_SR_TAF, BS_RTC_SR_TAF))
#endif
//@}

/*!
 * @name Register RTC_SR, field TCE[4] (RW)
 *
 * When time counter is disabled the TSR register and TPR register are
 * writeable, but do not increment. When time counter is enabled the TSR register and TPR
 * register are not writeable, but increment.
 *
 * Values:
 * - 0 - Time counter is disabled.
 * - 1 - Time counter is enabled.
 */
//@{
#define BP_RTC_SR_TCE        (4U)          //!< Bit position for RTC_SR_TCE.
#define BM_RTC_SR_TCE        (0x00000010U) //!< Bit mask for RTC_SR_TCE.
#define BS_RTC_SR_TCE        (1U)          //!< Bit field size in bits for RTC_SR_TCE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_SR_TCE field.
#define BR_RTC_SR_TCE        (BME_UBFX32(HW_RTC_SR_ADDR, BP_RTC_SR_TCE, BS_RTC_SR_TCE))
#endif

//! @brief Format value for bitfield RTC_SR_TCE.
#define BF_RTC_SR_TCE(v)     (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_SR_TCE), uint32_t) & BM_RTC_SR_TCE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TCE field to a new value.
#define BW_RTC_SR_TCE(v)     (BME_BFI32(HW_RTC_SR_ADDR, ((uint32_t)(v) << BP_RTC_SR_TCE), BP_RTC_SR_TCE, 1))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_RTC_LR - RTC Lock Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_RTC_LR - RTC Lock Register (RW)
 *
 * Reset value: 0x000000FFU
 */
typedef union _hw_rtc_lr
{
    uint32_t U;
    struct _hw_rtc_lr_bitfields
    {
        uint32_t RESERVED0 : 3;        //!< [2:0]
        uint32_t TCL : 1;              //!< [3] Time Compensation Lock
        uint32_t CRL : 1;              //!< [4] Control Register Lock
        uint32_t SRL : 1;              //!< [5] Status Register Lock
        uint32_t LRL : 1;              //!< [6] Lock Register Lock
        uint32_t RESERVED1 : 25;       //!< [31:7]
    } B;
} hw_rtc_lr_t;
#endif

/*!
 * @name Constants and macros for entire RTC_LR register
 */
//@{
#define HW_RTC_LR_ADDR           (REGS_RTC_BASE + 0x18U)

#ifndef __LANGUAGE_ASM__
#define HW_RTC_LR                (*(__IO hw_rtc_lr_t *) HW_RTC_LR_ADDR)
#define HW_RTC_LR_RD()           (HW_RTC_LR.U)
#define HW_RTC_LR_WR(v)          (HW_RTC_LR.U = (v))
#define HW_RTC_LR_SET(v)         (BME_OR32(HW_RTC_LR_ADDR, (uint32_t)(v)))
#define HW_RTC_LR_CLR(v)         (BME_AND32(HW_RTC_LR_ADDR, (uint32_t)(~(v))))
#define HW_RTC_LR_TOG(v)         (BME_XOR32(HW_RTC_LR_ADDR, (uint32_t)(v)))
#endif
//@}

/*
 * Constants & macros for individual RTC_LR bitfields
 */

/*!
 * @name Register RTC_LR, field TCL[3] (RW)
 *
 * After being cleared, this bit can be set only by POR or software reset.
 *
 * Values:
 * - 0 - Time Compensation Register is locked and writes are ignored.
 * - 1 - Time Compensation Register is not locked and writes complete as normal.
 */
//@{
#define BP_RTC_LR_TCL        (3U)          //!< Bit position for RTC_LR_TCL.
#define BM_RTC_LR_TCL        (0x00000008U) //!< Bit mask for RTC_LR_TCL.
#define BS_RTC_LR_TCL        (1U)          //!< Bit field size in bits for RTC_LR_TCL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_LR_TCL field.
#define BR_RTC_LR_TCL        (BME_UBFX32(HW_RTC_LR_ADDR, BP_RTC_LR_TCL, BS_RTC_LR_TCL))
#endif

//! @brief Format value for bitfield RTC_LR_TCL.
#define BF_RTC_LR_TCL(v)     (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_LR_TCL), uint32_t) & BM_RTC_LR_TCL)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TCL field to a new value.
#define BW_RTC_LR_TCL(v)     (BME_BFI32(HW_RTC_LR_ADDR, ((uint32_t)(v) << BP_RTC_LR_TCL), BP_RTC_LR_TCL, 1))
#endif
//@}

/*!
 * @name Register RTC_LR, field CRL[4] (RW)
 *
 * After being cleared, this bit can only be set by POR.
 *
 * Values:
 * - 0 - Control Register is locked and writes are ignored.
 * - 1 - Control Register is not locked and writes complete as normal.
 */
//@{
#define BP_RTC_LR_CRL        (4U)          //!< Bit position for RTC_LR_CRL.
#define BM_RTC_LR_CRL        (0x00000010U) //!< Bit mask for RTC_LR_CRL.
#define BS_RTC_LR_CRL        (1U)          //!< Bit field size in bits for RTC_LR_CRL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_LR_CRL field.
#define BR_RTC_LR_CRL        (BME_UBFX32(HW_RTC_LR_ADDR, BP_RTC_LR_CRL, BS_RTC_LR_CRL))
#endif

//! @brief Format value for bitfield RTC_LR_CRL.
#define BF_RTC_LR_CRL(v)     (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_LR_CRL), uint32_t) & BM_RTC_LR_CRL)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CRL field to a new value.
#define BW_RTC_LR_CRL(v)     (BME_BFI32(HW_RTC_LR_ADDR, ((uint32_t)(v) << BP_RTC_LR_CRL), BP_RTC_LR_CRL, 1))
#endif
//@}

/*!
 * @name Register RTC_LR, field SRL[5] (RW)
 *
 * After being cleared, this bit can be set only by POR or software reset.
 *
 * Values:
 * - 0 - Status Register is locked and writes are ignored.
 * - 1 - Status Register is not locked and writes complete as normal.
 */
//@{
#define BP_RTC_LR_SRL        (5U)          //!< Bit position for RTC_LR_SRL.
#define BM_RTC_LR_SRL        (0x00000020U) //!< Bit mask for RTC_LR_SRL.
#define BS_RTC_LR_SRL        (1U)          //!< Bit field size in bits for RTC_LR_SRL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_LR_SRL field.
#define BR_RTC_LR_SRL        (BME_UBFX32(HW_RTC_LR_ADDR, BP_RTC_LR_SRL, BS_RTC_LR_SRL))
#endif

//! @brief Format value for bitfield RTC_LR_SRL.
#define BF_RTC_LR_SRL(v)     (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_LR_SRL), uint32_t) & BM_RTC_LR_SRL)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SRL field to a new value.
#define BW_RTC_LR_SRL(v)     (BME_BFI32(HW_RTC_LR_ADDR, ((uint32_t)(v) << BP_RTC_LR_SRL), BP_RTC_LR_SRL, 1))
#endif
//@}

/*!
 * @name Register RTC_LR, field LRL[6] (RW)
 *
 * After being cleared, this bit can be set only by POR or software reset.
 *
 * Values:
 * - 0 - Lock Register is locked and writes are ignored.
 * - 1 - Lock Register is not locked and writes complete as normal.
 */
//@{
#define BP_RTC_LR_LRL        (6U)          //!< Bit position for RTC_LR_LRL.
#define BM_RTC_LR_LRL        (0x00000040U) //!< Bit mask for RTC_LR_LRL.
#define BS_RTC_LR_LRL        (1U)          //!< Bit field size in bits for RTC_LR_LRL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_LR_LRL field.
#define BR_RTC_LR_LRL        (BME_UBFX32(HW_RTC_LR_ADDR, BP_RTC_LR_LRL, BS_RTC_LR_LRL))
#endif

//! @brief Format value for bitfield RTC_LR_LRL.
#define BF_RTC_LR_LRL(v)     (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_LR_LRL), uint32_t) & BM_RTC_LR_LRL)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LRL field to a new value.
#define BW_RTC_LR_LRL(v)     (BME_BFI32(HW_RTC_LR_ADDR, ((uint32_t)(v) << BP_RTC_LR_LRL), BP_RTC_LR_LRL, 1))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_RTC_IER - RTC Interrupt Enable Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_RTC_IER - RTC Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000007U
 */
typedef union _hw_rtc_ier
{
    uint32_t U;
    struct _hw_rtc_ier_bitfields
    {
        uint32_t TIIE : 1;             //!< [0] Time Invalid Interrupt Enable
        uint32_t TOIE : 1;             //!< [1] Time Overflow Interrupt Enable
        uint32_t TAIE : 1;             //!< [2] Time Alarm Interrupt Enable
        uint32_t RESERVED0 : 1;        //!< [3]
        uint32_t TSIE : 1;             //!< [4] Time Seconds Interrupt Enable
        uint32_t RESERVED1 : 2;        //!< [6:5]
        uint32_t WPON : 1;             //!< [7] Wakeup Pin On
        uint32_t RESERVED2 : 24;       //!< [31:8]
    } B;
} hw_rtc_ier_t;
#endif

/*!
 * @name Constants and macros for entire RTC_IER register
 */
//@{
#define HW_RTC_IER_ADDR          (REGS_RTC_BASE + 0x1CU)

#ifndef __LANGUAGE_ASM__
#define HW_RTC_IER               (*(__IO hw_rtc_ier_t *) HW_RTC_IER_ADDR)
#define HW_RTC_IER_RD()          (HW_RTC_IER.U)
#define HW_RTC_IER_WR(v)         (HW_RTC_IER.U = (v))
#define HW_RTC_IER_SET(v)        (BME_OR32(HW_RTC_IER_ADDR, (uint32_t)(v)))
#define HW_RTC_IER_CLR(v)        (BME_AND32(HW_RTC_IER_ADDR, (uint32_t)(~(v))))
#define HW_RTC_IER_TOG(v)        (BME_XOR32(HW_RTC_IER_ADDR, (uint32_t)(v)))
#endif
//@}

/*
 * Constants & macros for individual RTC_IER bitfields
 */

/*!
 * @name Register RTC_IER, field TIIE[0] (RW)
 *
 * Values:
 * - 0 - Time invalid flag does not generate an interrupt.
 * - 1 - Time invalid flag does generate an interrupt.
 */
//@{
#define BP_RTC_IER_TIIE      (0U)          //!< Bit position for RTC_IER_TIIE.
#define BM_RTC_IER_TIIE      (0x00000001U) //!< Bit mask for RTC_IER_TIIE.
#define BS_RTC_IER_TIIE      (1U)          //!< Bit field size in bits for RTC_IER_TIIE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_IER_TIIE field.
#define BR_RTC_IER_TIIE      (BME_UBFX32(HW_RTC_IER_ADDR, BP_RTC_IER_TIIE, BS_RTC_IER_TIIE))
#endif

//! @brief Format value for bitfield RTC_IER_TIIE.
#define BF_RTC_IER_TIIE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_IER_TIIE), uint32_t) & BM_RTC_IER_TIIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TIIE field to a new value.
#define BW_RTC_IER_TIIE(v)   (BME_BFI32(HW_RTC_IER_ADDR, ((uint32_t)(v) << BP_RTC_IER_TIIE), BP_RTC_IER_TIIE, 1))
#endif
//@}

/*!
 * @name Register RTC_IER, field TOIE[1] (RW)
 *
 * Values:
 * - 0 - Time overflow flag does not generate an interrupt.
 * - 1 - Time overflow flag does generate an interrupt.
 */
//@{
#define BP_RTC_IER_TOIE      (1U)          //!< Bit position for RTC_IER_TOIE.
#define BM_RTC_IER_TOIE      (0x00000002U) //!< Bit mask for RTC_IER_TOIE.
#define BS_RTC_IER_TOIE      (1U)          //!< Bit field size in bits for RTC_IER_TOIE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_IER_TOIE field.
#define BR_RTC_IER_TOIE      (BME_UBFX32(HW_RTC_IER_ADDR, BP_RTC_IER_TOIE, BS_RTC_IER_TOIE))
#endif

//! @brief Format value for bitfield RTC_IER_TOIE.
#define BF_RTC_IER_TOIE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_IER_TOIE), uint32_t) & BM_RTC_IER_TOIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TOIE field to a new value.
#define BW_RTC_IER_TOIE(v)   (BME_BFI32(HW_RTC_IER_ADDR, ((uint32_t)(v) << BP_RTC_IER_TOIE), BP_RTC_IER_TOIE, 1))
#endif
//@}

/*!
 * @name Register RTC_IER, field TAIE[2] (RW)
 *
 * Values:
 * - 0 - Time alarm flag does not generate an interrupt.
 * - 1 - Time alarm flag does generate an interrupt.
 */
//@{
#define BP_RTC_IER_TAIE      (2U)          //!< Bit position for RTC_IER_TAIE.
#define BM_RTC_IER_TAIE      (0x00000004U) //!< Bit mask for RTC_IER_TAIE.
#define BS_RTC_IER_TAIE      (1U)          //!< Bit field size in bits for RTC_IER_TAIE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_IER_TAIE field.
#define BR_RTC_IER_TAIE      (BME_UBFX32(HW_RTC_IER_ADDR, BP_RTC_IER_TAIE, BS_RTC_IER_TAIE))
#endif

//! @brief Format value for bitfield RTC_IER_TAIE.
#define BF_RTC_IER_TAIE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_IER_TAIE), uint32_t) & BM_RTC_IER_TAIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TAIE field to a new value.
#define BW_RTC_IER_TAIE(v)   (BME_BFI32(HW_RTC_IER_ADDR, ((uint32_t)(v) << BP_RTC_IER_TAIE), BP_RTC_IER_TAIE, 1))
#endif
//@}

/*!
 * @name Register RTC_IER, field TSIE[4] (RW)
 *
 * The seconds interrupt is an edge-sensitive interrupt with a dedicated
 * interrupt vector. It is generated once a second and requires no software overhead
 * (there is no corresponding status flag to clear).
 *
 * Values:
 * - 0 - Seconds interrupt is disabled.
 * - 1 - Seconds interrupt is enabled.
 */
//@{
#define BP_RTC_IER_TSIE      (4U)          //!< Bit position for RTC_IER_TSIE.
#define BM_RTC_IER_TSIE      (0x00000010U) //!< Bit mask for RTC_IER_TSIE.
#define BS_RTC_IER_TSIE      (1U)          //!< Bit field size in bits for RTC_IER_TSIE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_IER_TSIE field.
#define BR_RTC_IER_TSIE      (BME_UBFX32(HW_RTC_IER_ADDR, BP_RTC_IER_TSIE, BS_RTC_IER_TSIE))
#endif

//! @brief Format value for bitfield RTC_IER_TSIE.
#define BF_RTC_IER_TSIE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_IER_TSIE), uint32_t) & BM_RTC_IER_TSIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TSIE field to a new value.
#define BW_RTC_IER_TSIE(v)   (BME_BFI32(HW_RTC_IER_ADDR, ((uint32_t)(v) << BP_RTC_IER_TSIE), BP_RTC_IER_TSIE, 1))
#endif
//@}

/*!
 * @name Register RTC_IER, field WPON[7] (RW)
 *
 * The wakeup pin is optional and not available on all devices. Whenever the
 * wakeup pin is enabled and this bit is set, the wakeup pin will assert.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - If the wakeup pin is enabled, then the wakeup pin will assert.
 */
//@{
#define BP_RTC_IER_WPON      (7U)          //!< Bit position for RTC_IER_WPON.
#define BM_RTC_IER_WPON      (0x00000080U) //!< Bit mask for RTC_IER_WPON.
#define BS_RTC_IER_WPON      (1U)          //!< Bit field size in bits for RTC_IER_WPON.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the RTC_IER_WPON field.
#define BR_RTC_IER_WPON      (BME_UBFX32(HW_RTC_IER_ADDR, BP_RTC_IER_WPON, BS_RTC_IER_WPON))
#endif

//! @brief Format value for bitfield RTC_IER_WPON.
#define BF_RTC_IER_WPON(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_RTC_IER_WPON), uint32_t) & BM_RTC_IER_WPON)

#ifndef __LANGUAGE_ASM__
//! @brief Set the WPON field to a new value.
#define BW_RTC_IER_WPON(v)   (BME_BFI32(HW_RTC_IER_ADDR, ((uint32_t)(v) << BP_RTC_IER_WPON), BP_RTC_IER_WPON, 1))
#endif
//@}

//-------------------------------------------------------------------------------------------
// hw_rtc_t - module struct
//-------------------------------------------------------------------------------------------
/*!
 * @brief All RTC module registers.
 */
#ifndef __LANGUAGE_ASM__
#pragma pack(1)
typedef struct _hw_rtc
{
    __IO hw_rtc_tsr_t TSR;                 //!< [0x0] RTC Time Seconds Register
    __IO hw_rtc_tpr_t TPR;                 //!< [0x4] RTC Time Prescaler Register
    __IO hw_rtc_tar_t TAR;                 //!< [0x8] RTC Time Alarm Register
    __IO hw_rtc_tcr_t TCR;                 //!< [0xC] RTC Time Compensation Register
    __IO hw_rtc_cr_t CR;                   //!< [0x10] RTC Control Register
    __IO hw_rtc_sr_t SR;                   //!< [0x14] RTC Status Register
    __IO hw_rtc_lr_t LR;                   //!< [0x18] RTC Lock Register
    __IO hw_rtc_ier_t IER;                 //!< [0x1C] RTC Interrupt Enable Register
} hw_rtc_t;
#pragma pack()

//! @brief Macro to access all RTC registers.
//! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
//!     use the '&' operator, like <code>&HW_RTC</code>.
#define HW_RTC         (*(hw_rtc_t *) REGS_RTC_BASE)
#endif

#endif // __HW_RTC_REGISTERS_H__
// v22/130726/0.9
// EOF

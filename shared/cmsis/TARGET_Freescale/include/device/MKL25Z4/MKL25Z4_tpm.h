/*
 * Copyright (c) 2014, Freescale Semiconductor, Inc.
 * All rights reserved.
 *
 * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL FREESCALE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */
/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_TPM_REGISTERS_H__
#define __HW_TPM_REGISTERS_H__

#include "regs.h"

/*
 * MKL25Z4 TPM
 *
 * Timer/PWM Module
 *
 * Registers defined in this header file:
 * - HW_TPM_SC - Status and Control
 * - HW_TPM_CNT - Counter
 * - HW_TPM_MOD - Modulo
 * - HW_TPM_CnSC - Channel (n) Status and Control
 * - HW_TPM_CnV - Channel (n) Value
 * - HW_TPM_STATUS - Capture and Compare Status
 * - HW_TPM_CONF - Configuration
 *
 * - hw_tpm_t - Struct containing all module registers.
 */

//! @name Module base addresses
//@{
#ifndef REGS_TPM_BASE
#define HW_TPM_INSTANCE_COUNT (3U) //!< Number of instances of the TPM module.
#define HW_TPM0 (0U) //!< Instance number for TPM0.
#define HW_TPM1 (1U) //!< Instance number for TPM1.
#define HW_TPM2 (2U) //!< Instance number for TPM2.
#define REGS_TPM0_BASE (0x40038000U) //!< Base address for TPM0.
#define REGS_TPM1_BASE (0x40039000U) //!< Base address for TPM1.
#define REGS_TPM2_BASE (0x4003A000U) //!< Base address for TPM2.

//! @brief Table of base addresses for TPM instances.
static const uint32_t __g_regs_TPM_base_addresses[] = {
        REGS_TPM0_BASE,
        REGS_TPM1_BASE,
        REGS_TPM2_BASE,
    };

//! @brief Get the base address of TPM by instance number.
//! @param x TPM instance number, from 0 through 2.
#define REGS_TPM_BASE(x) (__g_regs_TPM_base_addresses[(x)])

//! @brief Get the instance number given a base address.
//! @param b Base address for an instance of TPM.
#define REGS_TPM_INSTANCE(b) ((b) == REGS_TPM0_BASE ? HW_TPM0 : (b) == REGS_TPM1_BASE ? HW_TPM1 : (b) == REGS_TPM2_BASE ? HW_TPM2 : 0)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_TPM_SC - Status and Control
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_TPM_SC - Status and Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * SC contains the overflow status flag and control bits used to configure the
 * interrupt enable, module configuration and prescaler factor. These controls
 * relate to all channels within this module.
 */
typedef union _hw_tpm_sc
{
    uint32_t U;
    struct _hw_tpm_sc_bitfields
    {
        uint32_t PS : 3;               //!< [2:0] Prescale Factor Selection
        uint32_t CMOD : 2;             //!< [4:3] Clock Mode Selection
        uint32_t CPWMS : 1;            //!< [5] Center-aligned PWM Select
        uint32_t TOIE : 1;             //!< [6] Timer Overflow Interrupt Enable
        uint32_t TOF : 1;              //!< [7] Timer Overflow Flag
        uint32_t DMAb : 1;             //!< [8] DMA Enable
        uint32_t RESERVED0 : 23;       //!< [31:9]
    } B;
} hw_tpm_sc_t;
#endif

/*!
 * @name Constants and macros for entire TPM_SC register
 */
//@{
#define HW_TPM_SC_ADDR(x)        (REGS_TPM_BASE(x) + 0x0U)

#ifndef __LANGUAGE_ASM__
#define HW_TPM_SC(x)             (*(__IO hw_tpm_sc_t *) HW_TPM_SC_ADDR(x))
#define HW_TPM_SC_RD(x)          (HW_TPM_SC(x).U)
#define HW_TPM_SC_WR(x, v)       (HW_TPM_SC(x).U = (v))
#define HW_TPM_SC_SET(x, v)      (BME_OR32(HW_TPM_SC_ADDR(x), (uint32_t)(v)))
#define HW_TPM_SC_CLR(x, v)      (BME_AND32(HW_TPM_SC_ADDR(x), (uint32_t)(~(v))))
#define HW_TPM_SC_TOG(x, v)      (BME_XOR32(HW_TPM_SC_ADDR(x), (uint32_t)(v)))
#endif
//@}

/*
 * Constants & macros for individual TPM_SC bitfields
 */

/*!
 * @name Register TPM_SC, field PS[2:0] (RW)
 *
 * Selects one of 8 division factors for the clock mode selected by CMOD. This
 * field is write protected. It can be written only when the counter is disabled.
 *
 * Values:
 * - 000 - Divide by 1
 * - 001 - Divide by 2
 * - 010 - Divide by 4
 * - 011 - Divide by 8
 * - 100 - Divide by 16
 * - 101 - Divide by 32
 * - 110 - Divide by 64
 * - 111 - Divide by 128
 */
//@{
#define BP_TPM_SC_PS         (0U)          //!< Bit position for TPM_SC_PS.
#define BM_TPM_SC_PS         (0x00000007U) //!< Bit mask for TPM_SC_PS.
#define BS_TPM_SC_PS         (3U)          //!< Bit field size in bits for TPM_SC_PS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_SC_PS field.
#define BR_TPM_SC_PS(x)      (BME_UBFX32(HW_TPM_SC_ADDR(x), BP_TPM_SC_PS, BS_TPM_SC_PS))
#endif

//! @brief Format value for bitfield TPM_SC_PS.
#define BF_TPM_SC_PS(v)      (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_SC_PS), uint32_t) & BM_TPM_SC_PS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PS field to a new value.
#define BW_TPM_SC_PS(x, v)   (BME_BFI32(HW_TPM_SC_ADDR(x), ((uint32_t)(v) << BP_TPM_SC_PS), BP_TPM_SC_PS, 3))
#endif
//@}

/*!
 * @name Register TPM_SC, field CMOD[4:3] (RW)
 *
 * Selects the LPTPM counter clock modes. When disabling the counter, this field
 * remain set until acknolwedged in the LPTPM clock domain.
 *
 * Values:
 * - 00 - LPTPM counter is disabled
 * - 01 - LPTPM counter increments on every LPTPM counter clock
 * - 10 - LPTPM counter increments on rising edge of LPTPM_EXTCLK synchronized
 *     to the LPTPM counter clock
 * - 11 - Reserved
 */
//@{
#define BP_TPM_SC_CMOD       (3U)          //!< Bit position for TPM_SC_CMOD.
#define BM_TPM_SC_CMOD       (0x00000018U) //!< Bit mask for TPM_SC_CMOD.
#define BS_TPM_SC_CMOD       (2U)          //!< Bit field size in bits for TPM_SC_CMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_SC_CMOD field.
#define BR_TPM_SC_CMOD(x)    (BME_UBFX32(HW_TPM_SC_ADDR(x), BP_TPM_SC_CMOD, BS_TPM_SC_CMOD))
#endif

//! @brief Format value for bitfield TPM_SC_CMOD.
#define BF_TPM_SC_CMOD(v)    (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_SC_CMOD), uint32_t) & BM_TPM_SC_CMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CMOD field to a new value.
#define BW_TPM_SC_CMOD(x, v) (BME_BFI32(HW_TPM_SC_ADDR(x), ((uint32_t)(v) << BP_TPM_SC_CMOD), BP_TPM_SC_CMOD, 2))
#endif
//@}

/*!
 * @name Register TPM_SC, field CPWMS[5] (RW)
 *
 * Selects CPWM mode. This mode configures the LPTPM to operate in up-down
 * counting mode. This field is write protected. It can be written only when the
 * counter is disabled.
 *
 * Values:
 * - 0 - LPTPM counter operates in up counting mode.
 * - 1 - LPTPM counter operates in up-down counting mode.
 */
//@{
#define BP_TPM_SC_CPWMS      (5U)          //!< Bit position for TPM_SC_CPWMS.
#define BM_TPM_SC_CPWMS      (0x00000020U) //!< Bit mask for TPM_SC_CPWMS.
#define BS_TPM_SC_CPWMS      (1U)          //!< Bit field size in bits for TPM_SC_CPWMS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_SC_CPWMS field.
#define BR_TPM_SC_CPWMS(x)   (BME_UBFX32(HW_TPM_SC_ADDR(x), BP_TPM_SC_CPWMS, BS_TPM_SC_CPWMS))
#endif

//! @brief Format value for bitfield TPM_SC_CPWMS.
#define BF_TPM_SC_CPWMS(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_SC_CPWMS), uint32_t) & BM_TPM_SC_CPWMS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CPWMS field to a new value.
#define BW_TPM_SC_CPWMS(x, v) (BME_BFI32(HW_TPM_SC_ADDR(x), ((uint32_t)(v) << BP_TPM_SC_CPWMS), BP_TPM_SC_CPWMS, 1))
#endif
//@}

/*!
 * @name Register TPM_SC, field TOIE[6] (RW)
 *
 * Enables LPTPM overflow interrupts.
 *
 * Values:
 * - 0 - Disable TOF interrupts. Use software polling or DMA request.
 * - 1 - Enable TOF interrupts. An interrupt is generated when TOF equals one.
 */
//@{
#define BP_TPM_SC_TOIE       (6U)          //!< Bit position for TPM_SC_TOIE.
#define BM_TPM_SC_TOIE       (0x00000040U) //!< Bit mask for TPM_SC_TOIE.
#define BS_TPM_SC_TOIE       (1U)          //!< Bit field size in bits for TPM_SC_TOIE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_SC_TOIE field.
#define BR_TPM_SC_TOIE(x)    (BME_UBFX32(HW_TPM_SC_ADDR(x), BP_TPM_SC_TOIE, BS_TPM_SC_TOIE))
#endif

//! @brief Format value for bitfield TPM_SC_TOIE.
#define BF_TPM_SC_TOIE(v)    (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_SC_TOIE), uint32_t) & BM_TPM_SC_TOIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TOIE field to a new value.
#define BW_TPM_SC_TOIE(x, v) (BME_BFI32(HW_TPM_SC_ADDR(x), ((uint32_t)(v) << BP_TPM_SC_TOIE), BP_TPM_SC_TOIE, 1))
#endif
//@}

/*!
 * @name Register TPM_SC, field TOF[7] (W1C)
 *
 * Set by hardware when the LPTPM counter equals the value in the MOD register
 * and increments. The TOF bit is cleared by writing a 1 to TOF bit. Writing a 0
 * to TOF has no effect. If another LPTPM overflow occurs between the flag setting
 * and the flag clearing, the write operation has no effect; therefore, TOF
 * remains set indicating another overflow has occurred. In this case a TOF interrupt
 * request is not lost due to a delay in clearing the previous TOF.
 *
 * Values:
 * - 0 - LPTPM counter has not overflowed.
 * - 1 - LPTPM counter has overflowed.
 */
//@{
#define BP_TPM_SC_TOF        (7U)          //!< Bit position for TPM_SC_TOF.
#define BM_TPM_SC_TOF        (0x00000080U) //!< Bit mask for TPM_SC_TOF.
#define BS_TPM_SC_TOF        (1U)          //!< Bit field size in bits for TPM_SC_TOF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_SC_TOF field.
#define BR_TPM_SC_TOF(x)     (BME_UBFX32(HW_TPM_SC_ADDR(x), BP_TPM_SC_TOF, BS_TPM_SC_TOF))
#endif

//! @brief Format value for bitfield TPM_SC_TOF.
#define BF_TPM_SC_TOF(v)     (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_SC_TOF), uint32_t) & BM_TPM_SC_TOF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TOF field to a new value.
#define BW_TPM_SC_TOF(x, v)  (BME_BFI32(HW_TPM_SC_ADDR(x), ((uint32_t)(v) << BP_TPM_SC_TOF), BP_TPM_SC_TOF, 1))
#endif
//@}

/*!
 * @name Register TPM_SC, field DMA[8] (RW)
 *
 * Enables DMA transfers for the overflow flag.
 *
 * Values:
 * - 0 - Disables DMA transfers.
 * - 1 - Enables DMA transfers.
 */
//@{
#define BP_TPM_SC_DMA        (8U)          //!< Bit position for TPM_SC_DMA.
#define BM_TPM_SC_DMA        (0x00000100U) //!< Bit mask for TPM_SC_DMA.
#define BS_TPM_SC_DMA        (1U)          //!< Bit field size in bits for TPM_SC_DMA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_SC_DMA field.
#define BR_TPM_SC_DMA(x)     (BME_UBFX32(HW_TPM_SC_ADDR(x), BP_TPM_SC_DMA, BS_TPM_SC_DMA))
#endif

//! @brief Format value for bitfield TPM_SC_DMA.
#define BF_TPM_SC_DMA(v)     (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_SC_DMA), uint32_t) & BM_TPM_SC_DMA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA field to a new value.
#define BW_TPM_SC_DMA(x, v)  (BME_BFI32(HW_TPM_SC_ADDR(x), ((uint32_t)(v) << BP_TPM_SC_DMA), BP_TPM_SC_DMA, 1))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_TPM_CNT - Counter
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_TPM_CNT - Counter (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CNT register contains the LPTPM counter value. Reset clears the CNT
 * register. Writing any value to COUNT also clears the counter. When debug is active,
 * the LPTPM counter does not increment unless configured otherwise. Reading the
 * CNT register adds two wait states to the register access due to
 * synchronization delays.
 */
typedef union _hw_tpm_cnt
{
    uint32_t U;
    struct _hw_tpm_cnt_bitfields
    {
        uint32_t COUNT : 16;           //!< [15:0] Counter value
        uint32_t RESERVED0 : 16;       //!< [31:16]
    } B;
} hw_tpm_cnt_t;
#endif

/*!
 * @name Constants and macros for entire TPM_CNT register
 */
//@{
#define HW_TPM_CNT_ADDR(x)       (REGS_TPM_BASE(x) + 0x4U)

#ifndef __LANGUAGE_ASM__
#define HW_TPM_CNT(x)            (*(__IO hw_tpm_cnt_t *) HW_TPM_CNT_ADDR(x))
#define HW_TPM_CNT_RD(x)         (HW_TPM_CNT(x).U)
#define HW_TPM_CNT_WR(x, v)      (HW_TPM_CNT(x).U = (v))
#define HW_TPM_CNT_SET(x, v)     (BME_OR32(HW_TPM_CNT_ADDR(x), (uint32_t)(v)))
#define HW_TPM_CNT_CLR(x, v)     (BME_AND32(HW_TPM_CNT_ADDR(x), (uint32_t)(~(v))))
#define HW_TPM_CNT_TOG(x, v)     (BME_XOR32(HW_TPM_CNT_ADDR(x), (uint32_t)(v)))
#endif
//@}

/*
 * Constants & macros for individual TPM_CNT bitfields
 */

/*!
 * @name Register TPM_CNT, field COUNT[15:0] (RW)
 */
//@{
#define BP_TPM_CNT_COUNT     (0U)          //!< Bit position for TPM_CNT_COUNT.
#define BM_TPM_CNT_COUNT     (0x0000FFFFU) //!< Bit mask for TPM_CNT_COUNT.
#define BS_TPM_CNT_COUNT     (16U)         //!< Bit field size in bits for TPM_CNT_COUNT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_CNT_COUNT field.
#define BR_TPM_CNT_COUNT(x)  (BME_UBFX32(HW_TPM_CNT_ADDR(x), BP_TPM_CNT_COUNT, BS_TPM_CNT_COUNT))
#endif

//! @brief Format value for bitfield TPM_CNT_COUNT.
#define BF_TPM_CNT_COUNT(v)  (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_CNT_COUNT), uint32_t) & BM_TPM_CNT_COUNT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the COUNT field to a new value.
#define BW_TPM_CNT_COUNT(x, v) (BME_BFI32(HW_TPM_CNT_ADDR(x), ((uint32_t)(v) << BP_TPM_CNT_COUNT), BP_TPM_CNT_COUNT, 16))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_TPM_MOD - Modulo
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_TPM_MOD - Modulo (RW)
 *
 * Reset value: 0x0000FFFFU
 *
 * The Modulo register contains the modulo value for the LPTPM counter. When the
 * LPTPM counter reaches the modulo value and increments, the overflow flag
 * (TOF) is set and the next value of LPTPM counter depends on the selected counting
 * method (see Counter ). Writing to the MOD register latches the value into a
 * buffer. The MOD register is updated with the value of its write buffer according
 * to MOD Register Update . It is recommended to initialize the LPTPM counter
 * (write to CNT) before writing to the MOD register to avoid confusion about when
 * the first counter overflow will occur.
 */
typedef union _hw_tpm_mod
{
    uint32_t U;
    struct _hw_tpm_mod_bitfields
    {
        uint32_t MOD : 16;             //!< [15:0] Modulo value
        uint32_t RESERVED0 : 16;       //!< [31:16]
    } B;
} hw_tpm_mod_t;
#endif

/*!
 * @name Constants and macros for entire TPM_MOD register
 */
//@{
#define HW_TPM_MOD_ADDR(x)       (REGS_TPM_BASE(x) + 0x8U)

#ifndef __LANGUAGE_ASM__
#define HW_TPM_MOD(x)            (*(__IO hw_tpm_mod_t *) HW_TPM_MOD_ADDR(x))
#define HW_TPM_MOD_RD(x)         (HW_TPM_MOD(x).U)
#define HW_TPM_MOD_WR(x, v)      (HW_TPM_MOD(x).U = (v))
#define HW_TPM_MOD_SET(x, v)     (BME_OR32(HW_TPM_MOD_ADDR(x), (uint32_t)(v)))
#define HW_TPM_MOD_CLR(x, v)     (BME_AND32(HW_TPM_MOD_ADDR(x), (uint32_t)(~(v))))
#define HW_TPM_MOD_TOG(x, v)     (BME_XOR32(HW_TPM_MOD_ADDR(x), (uint32_t)(v)))
#endif
//@}

/*
 * Constants & macros for individual TPM_MOD bitfields
 */

/*!
 * @name Register TPM_MOD, field MOD[15:0] (RW)
 *
 * When writing this field, all bytes must be written at the same time.
 */
//@{
#define BP_TPM_MOD_MOD       (0U)          //!< Bit position for TPM_MOD_MOD.
#define BM_TPM_MOD_MOD       (0x0000FFFFU) //!< Bit mask for TPM_MOD_MOD.
#define BS_TPM_MOD_MOD       (16U)         //!< Bit field size in bits for TPM_MOD_MOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_MOD_MOD field.
#define BR_TPM_MOD_MOD(x)    (BME_UBFX32(HW_TPM_MOD_ADDR(x), BP_TPM_MOD_MOD, BS_TPM_MOD_MOD))
#endif

//! @brief Format value for bitfield TPM_MOD_MOD.
#define BF_TPM_MOD_MOD(v)    (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_MOD_MOD), uint32_t) & BM_TPM_MOD_MOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MOD field to a new value.
#define BW_TPM_MOD_MOD(x, v) (BME_BFI32(HW_TPM_MOD_ADDR(x), ((uint32_t)(v) << BP_TPM_MOD_MOD), BP_TPM_MOD_MOD, 16))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_TPM_CnSC - Channel (n) Status and Control
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_TPM_CnSC - Channel (n) Status and Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * CnSC contains the channel-interrupt-status flag and control bits used to
 * configure the interrupt enable, channel configuration, and pin function. When
 * switching from one channel mode to a different channel mode, the channel must
 * first be disabled and this must be acknowledged in the LPTPM counter clock domain.
 * Mode, Edge, and Level Selection CPWMS MSnB:MSnA ELSnB:ELSnA Mode
 * Configuration X 00 00 None Channel disabled X 01/10/11 00 Software compare Pin not used
 * for LPTPM 0 00 01 Input capture Capture on Rising Edge Only 10 Capture on
 * Falling Edge Only 11 Capture on Rising or Falling Edge 01 01 Output compare Toggle
 * Output on match 10 Clear Output on match 11 Set Output on match 10 10
 * Edge-aligned PWM High-true pulses (clear Output on match, set Output on reload) X1
 * Low-true pulses (set Output on match, clear Output on reload) 11 10 Output compare
 * Pulse Output low on match X1 Pulse Output high on match 1 10 10
 * Center-aligned PWM High-true pulses (clear Output on match-up, set Output on match-down) X1
 * Low-true pulses (set Output on match-up, clear Output on match-down)
 */
typedef union _hw_tpm_cnsc
{
    uint32_t U;
    struct _hw_tpm_cnsc_bitfields
    {
        uint32_t DMAb : 1;             //!< [0] DMA Enable
        uint32_t RESERVED0 : 1;        //!< [1]
        uint32_t ELSA : 1;             //!< [2] Edge or Level Select
        uint32_t ELSB : 1;             //!< [3] Edge or Level Select
        uint32_t MSA : 1;              //!< [4] Channel Mode Select
        uint32_t MSB : 1;              //!< [5] Channel Mode Select
        uint32_t CHIE : 1;             //!< [6] Channel Interrupt Enable
        uint32_t CHF : 1;              //!< [7] Channel Flag
        uint32_t RESERVED1 : 24;       //!< [31:8]
    } B;
} hw_tpm_cnsc_t;
#endif

/*!
 * @name Constants and macros for entire TPM_CnSC register
 */
//@{
#define HW_TPM_CnSC_COUNT (6U)

#define HW_TPM_CnSC_ADDR(x, n)   (REGS_TPM_BASE(x) + 0xCU + (0x8U * n))

#ifndef __LANGUAGE_ASM__
#define HW_TPM_CnSC(x, n)        (*(__IO hw_tpm_cnsc_t *) HW_TPM_CnSC_ADDR(x, n))
#define HW_TPM_CnSC_RD(x, n)     (HW_TPM_CnSC(x, n).U)
#define HW_TPM_CnSC_WR(x, n, v)  (HW_TPM_CnSC(x, n).U = (v))
#define HW_TPM_CnSC_SET(x, n, v) (BME_OR32(HW_TPM_CnSC_ADDR(x, n), (uint32_t)(v)))
#define HW_TPM_CnSC_CLR(x, n, v) (BME_AND32(HW_TPM_CnSC_ADDR(x, n), (uint32_t)(~(v))))
#define HW_TPM_CnSC_TOG(x, n, v) (BME_XOR32(HW_TPM_CnSC_ADDR(x, n), (uint32_t)(v)))
#endif
//@}

/*
 * Constants & macros for individual TPM_CnSC bitfields
 */

/*!
 * @name Register TPM_CnSC, field DMA[0] (RW)
 *
 * Enables DMA transfers for the channel.
 *
 * Values:
 * - 0 - Disable DMA transfers.
 * - 1 - Enable DMA transfers.
 */
//@{
#define BP_TPM_CnSC_DMA      (0U)          //!< Bit position for TPM_CnSC_DMA.
#define BM_TPM_CnSC_DMA      (0x00000001U) //!< Bit mask for TPM_CnSC_DMA.
#define BS_TPM_CnSC_DMA      (1U)          //!< Bit field size in bits for TPM_CnSC_DMA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_CnSC_DMA field.
#define BR_TPM_CnSC_DMA(x, n) (BME_UBFX32(HW_TPM_CnSC_ADDR(x, n), BP_TPM_CnSC_DMA, BS_TPM_CnSC_DMA))
#endif

//! @brief Format value for bitfield TPM_CnSC_DMA.
#define BF_TPM_CnSC_DMA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_CnSC_DMA), uint32_t) & BM_TPM_CnSC_DMA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA field to a new value.
#define BW_TPM_CnSC_DMA(x, n, v) (BME_BFI32(HW_TPM_CnSC_ADDR(x, n), ((uint32_t)(v) << BP_TPM_CnSC_DMA), BP_TPM_CnSC_DMA, 1))
#endif
//@}

/*!
 * @name Register TPM_CnSC, field ELSA[2] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. When a
 * channel is disabled, this bit will not change state until acknowledged in the LPTPM
 * counter clock domain.
 */
//@{
#define BP_TPM_CnSC_ELSA     (2U)          //!< Bit position for TPM_CnSC_ELSA.
#define BM_TPM_CnSC_ELSA     (0x00000004U) //!< Bit mask for TPM_CnSC_ELSA.
#define BS_TPM_CnSC_ELSA     (1U)          //!< Bit field size in bits for TPM_CnSC_ELSA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_CnSC_ELSA field.
#define BR_TPM_CnSC_ELSA(x, n) (BME_UBFX32(HW_TPM_CnSC_ADDR(x, n), BP_TPM_CnSC_ELSA, BS_TPM_CnSC_ELSA))
#endif

//! @brief Format value for bitfield TPM_CnSC_ELSA.
#define BF_TPM_CnSC_ELSA(v)  (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_CnSC_ELSA), uint32_t) & BM_TPM_CnSC_ELSA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELSA field to a new value.
#define BW_TPM_CnSC_ELSA(x, n, v) (BME_BFI32(HW_TPM_CnSC_ADDR(x, n), ((uint32_t)(v) << BP_TPM_CnSC_ELSA), BP_TPM_CnSC_ELSA, 1))
#endif
//@}

/*!
 * @name Register TPM_CnSC, field ELSB[3] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. When a
 * channel is disabled, this bit will not change state until acknowledged in the LPTPM
 * counter clock domain.
 */
//@{
#define BP_TPM_CnSC_ELSB     (3U)          //!< Bit position for TPM_CnSC_ELSB.
#define BM_TPM_CnSC_ELSB     (0x00000008U) //!< Bit mask for TPM_CnSC_ELSB.
#define BS_TPM_CnSC_ELSB     (1U)          //!< Bit field size in bits for TPM_CnSC_ELSB.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_CnSC_ELSB field.
#define BR_TPM_CnSC_ELSB(x, n) (BME_UBFX32(HW_TPM_CnSC_ADDR(x, n), BP_TPM_CnSC_ELSB, BS_TPM_CnSC_ELSB))
#endif

//! @brief Format value for bitfield TPM_CnSC_ELSB.
#define BF_TPM_CnSC_ELSB(v)  (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_CnSC_ELSB), uint32_t) & BM_TPM_CnSC_ELSB)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ELSB field to a new value.
#define BW_TPM_CnSC_ELSB(x, n, v) (BME_BFI32(HW_TPM_CnSC_ADDR(x, n), ((uint32_t)(v) << BP_TPM_CnSC_ELSB), BP_TPM_CnSC_ELSB, 1))
#endif
//@}

/*!
 * @name Register TPM_CnSC, field MSA[4] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. When a channel is disabled, this bit will not change
 * state until acknowledged in the LPTPM counter clock domain.
 */
//@{
#define BP_TPM_CnSC_MSA      (4U)          //!< Bit position for TPM_CnSC_MSA.
#define BM_TPM_CnSC_MSA      (0x00000010U) //!< Bit mask for TPM_CnSC_MSA.
#define BS_TPM_CnSC_MSA      (1U)          //!< Bit field size in bits for TPM_CnSC_MSA.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_CnSC_MSA field.
#define BR_TPM_CnSC_MSA(x, n) (BME_UBFX32(HW_TPM_CnSC_ADDR(x, n), BP_TPM_CnSC_MSA, BS_TPM_CnSC_MSA))
#endif

//! @brief Format value for bitfield TPM_CnSC_MSA.
#define BF_TPM_CnSC_MSA(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_CnSC_MSA), uint32_t) & BM_TPM_CnSC_MSA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MSA field to a new value.
#define BW_TPM_CnSC_MSA(x, n, v) (BME_BFI32(HW_TPM_CnSC_ADDR(x, n), ((uint32_t)(v) << BP_TPM_CnSC_MSA), BP_TPM_CnSC_MSA, 1))
#endif
//@}

/*!
 * @name Register TPM_CnSC, field MSB[5] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. When a channel is disabled, this bit will not change
 * state until acknowledged in the LPTPM counter clock domain.
 */
//@{
#define BP_TPM_CnSC_MSB      (5U)          //!< Bit position for TPM_CnSC_MSB.
#define BM_TPM_CnSC_MSB      (0x00000020U) //!< Bit mask for TPM_CnSC_MSB.
#define BS_TPM_CnSC_MSB      (1U)          //!< Bit field size in bits for TPM_CnSC_MSB.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_CnSC_MSB field.
#define BR_TPM_CnSC_MSB(x, n) (BME_UBFX32(HW_TPM_CnSC_ADDR(x, n), BP_TPM_CnSC_MSB, BS_TPM_CnSC_MSB))
#endif

//! @brief Format value for bitfield TPM_CnSC_MSB.
#define BF_TPM_CnSC_MSB(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_CnSC_MSB), uint32_t) & BM_TPM_CnSC_MSB)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MSB field to a new value.
#define BW_TPM_CnSC_MSB(x, n, v) (BME_BFI32(HW_TPM_CnSC_ADDR(x, n), ((uint32_t)(v) << BP_TPM_CnSC_MSB), BP_TPM_CnSC_MSB, 1))
#endif
//@}

/*!
 * @name Register TPM_CnSC, field CHIE[6] (RW)
 *
 * Enables channel interrupts.
 *
 * Values:
 * - 0 - Disable channel interrupts.
 * - 1 - Enable channel interrupts.
 */
//@{
#define BP_TPM_CnSC_CHIE     (6U)          //!< Bit position for TPM_CnSC_CHIE.
#define BM_TPM_CnSC_CHIE     (0x00000040U) //!< Bit mask for TPM_CnSC_CHIE.
#define BS_TPM_CnSC_CHIE     (1U)          //!< Bit field size in bits for TPM_CnSC_CHIE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_CnSC_CHIE field.
#define BR_TPM_CnSC_CHIE(x, n) (BME_UBFX32(HW_TPM_CnSC_ADDR(x, n), BP_TPM_CnSC_CHIE, BS_TPM_CnSC_CHIE))
#endif

//! @brief Format value for bitfield TPM_CnSC_CHIE.
#define BF_TPM_CnSC_CHIE(v)  (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_CnSC_CHIE), uint32_t) & BM_TPM_CnSC_CHIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHIE field to a new value.
#define BW_TPM_CnSC_CHIE(x, n, v) (BME_BFI32(HW_TPM_CnSC_ADDR(x, n), ((uint32_t)(v) << BP_TPM_CnSC_CHIE), BP_TPM_CnSC_CHIE, 1))
#endif
//@}

/*!
 * @name Register TPM_CnSC, field CHF[7] (W1C)
 *
 * Set by hardware when an event occurs on the channel. CHF is cleared by
 * writing a 1 to the CHF bit. Writing a 0 to CHF has no effect. If another event
 * occurs between the CHF sets and the write operation, the write operation has no
 * effect; therefore, CHF remains set indicating another event has occurred. In this
 * case a CHF interrupt request is not lost due to the delay in clearing the
 * previous CHF.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
//@{
#define BP_TPM_CnSC_CHF      (7U)          //!< Bit position for TPM_CnSC_CHF.
#define BM_TPM_CnSC_CHF      (0x00000080U) //!< Bit mask for TPM_CnSC_CHF.
#define BS_TPM_CnSC_CHF      (1U)          //!< Bit field size in bits for TPM_CnSC_CHF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_CnSC_CHF field.
#define BR_TPM_CnSC_CHF(x, n) (BME_UBFX32(HW_TPM_CnSC_ADDR(x, n), BP_TPM_CnSC_CHF, BS_TPM_CnSC_CHF))
#endif

//! @brief Format value for bitfield TPM_CnSC_CHF.
#define BF_TPM_CnSC_CHF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_CnSC_CHF), uint32_t) & BM_TPM_CnSC_CHF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHF field to a new value.
#define BW_TPM_CnSC_CHF(x, n, v) (BME_BFI32(HW_TPM_CnSC_ADDR(x, n), ((uint32_t)(v) << BP_TPM_CnSC_CHF), BP_TPM_CnSC_CHF, 1))
#endif
//@}
//-------------------------------------------------------------------------------------------
// HW_TPM_CnV - Channel (n) Value
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_TPM_CnV - Channel (n) Value (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the captured LPTPM counter value for the input modes
 * or the match value for the output modes. In input capture mode, any write to a
 * CnV register is ignored. In compare modes, writing to a CnV register latches
 * the value into a buffer. A CnV register is updated with the value of its write
 * buffer according to CnV Register Update .
 */
typedef union _hw_tpm_cnv
{
    uint32_t U;
    struct _hw_tpm_cnv_bitfields
    {
        uint32_t VAL : 16;             //!< [15:0] Channel Value
        uint32_t RESERVED0 : 16;       //!< [31:16]
    } B;
} hw_tpm_cnv_t;
#endif

/*!
 * @name Constants and macros for entire TPM_CnV register
 */
//@{
#define HW_TPM_CnV_COUNT (6U)

#define HW_TPM_CnV_ADDR(x, n)    (REGS_TPM_BASE(x) + 0x10U + (0x8U * n))

#ifndef __LANGUAGE_ASM__
#define HW_TPM_CnV(x, n)         (*(__IO hw_tpm_cnv_t *) HW_TPM_CnV_ADDR(x, n))
#define HW_TPM_CnV_RD(x, n)      (HW_TPM_CnV(x, n).U)
#define HW_TPM_CnV_WR(x, n, v)   (HW_TPM_CnV(x, n).U = (v))
#define HW_TPM_CnV_SET(x, n, v)  (BME_OR32(HW_TPM_CnV_ADDR(x, n), (uint32_t)(v)))
#define HW_TPM_CnV_CLR(x, n, v)  (BME_AND32(HW_TPM_CnV_ADDR(x, n), (uint32_t)(~(v))))
#define HW_TPM_CnV_TOG(x, n, v)  (BME_XOR32(HW_TPM_CnV_ADDR(x, n), (uint32_t)(v)))
#endif
//@}

/*
 * Constants & macros for individual TPM_CnV bitfields
 */

/*!
 * @name Register TPM_CnV, field VAL[15:0] (RW)
 *
 * Captured LPTPM counter value of the input modes or the match value for the
 * output modes. When writing this field, all bytes must be written at the same
 * time.
 */
//@{
#define BP_TPM_CnV_VAL       (0U)          //!< Bit position for TPM_CnV_VAL.
#define BM_TPM_CnV_VAL       (0x0000FFFFU) //!< Bit mask for TPM_CnV_VAL.
#define BS_TPM_CnV_VAL       (16U)         //!< Bit field size in bits for TPM_CnV_VAL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_CnV_VAL field.
#define BR_TPM_CnV_VAL(x, n) (BME_UBFX32(HW_TPM_CnV_ADDR(x, n), BP_TPM_CnV_VAL, BS_TPM_CnV_VAL))
#endif

//! @brief Format value for bitfield TPM_CnV_VAL.
#define BF_TPM_CnV_VAL(v)    (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_CnV_VAL), uint32_t) & BM_TPM_CnV_VAL)

#ifndef __LANGUAGE_ASM__
//! @brief Set the VAL field to a new value.
#define BW_TPM_CnV_VAL(x, n, v) (BME_BFI32(HW_TPM_CnV_ADDR(x, n), ((uint32_t)(v) << BP_TPM_CnV_VAL), BP_TPM_CnV_VAL, 16))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_TPM_STATUS - Capture and Compare Status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_TPM_STATUS - Capture and Compare Status (RW)
 *
 * Reset value: 0x00000000U
 *
 * The STATUS register contains a copy of the status flag CHnF bit (in CnSC) for
 * each LPTPM channel, as well as the TOF bit (in SC), for software convenience.
 * Each CHnF bit in STATUS is a mirror of CHnF bit in CnSC. All CHnF bits can be
 * checked using only one read of STATUS. All CHnF bits can be cleared by
 * writing all ones to STATUS. Hardware sets the individual channel flags when an event
 * occurs on the channel. CHF is cleared by writing a 1 to the CHF bit. Writing
 * a 0 to CHF has no effect. If another event occurs between the flag setting and
 * the write operation, the write operation has no effect; therefore, CHF
 * remains set indicating another event has occurred. In this case a CHF interrupt
 * request is not lost due to the clearing sequence for a previous CHF.
 */
typedef union _hw_tpm_status
{
    uint32_t U;
    struct _hw_tpm_status_bitfields
    {
        uint32_t CH0F : 1;             //!< [0] Channel 0 Flag
        uint32_t CH1F : 1;             //!< [1] Channel 1 Flag
        uint32_t CH2F : 1;             //!< [2] Channel 2 Flag
        uint32_t CH3F : 1;             //!< [3] Channel 3 Flag
        uint32_t CH4F : 1;             //!< [4] Channel 4 Flag
        uint32_t CH5F : 1;             //!< [5] Channel 5 Flag
        uint32_t RESERVED0 : 2;        //!< [7:6]
        uint32_t TOF : 1;              //!< [8] Timer Overflow Flag
        uint32_t RESERVED1 : 23;       //!< [31:9]
    } B;
} hw_tpm_status_t;
#endif

/*!
 * @name Constants and macros for entire TPM_STATUS register
 */
//@{
#define HW_TPM_STATUS_ADDR(x)    (REGS_TPM_BASE(x) + 0x50U)

#ifndef __LANGUAGE_ASM__
#define HW_TPM_STATUS(x)         (*(__IO hw_tpm_status_t *) HW_TPM_STATUS_ADDR(x))
#define HW_TPM_STATUS_RD(x)      (HW_TPM_STATUS(x).U)
#define HW_TPM_STATUS_WR(x, v)   (HW_TPM_STATUS(x).U = (v))
#define HW_TPM_STATUS_SET(x, v)  (BME_OR32(HW_TPM_STATUS_ADDR(x), (uint32_t)(v)))
#define HW_TPM_STATUS_CLR(x, v)  (BME_AND32(HW_TPM_STATUS_ADDR(x), (uint32_t)(~(v))))
#define HW_TPM_STATUS_TOG(x, v)  (BME_XOR32(HW_TPM_STATUS_ADDR(x), (uint32_t)(v)))
#endif
//@}

/*
 * Constants & macros for individual TPM_STATUS bitfields
 */

/*!
 * @name Register TPM_STATUS, field CH0F[0] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
//@{
#define BP_TPM_STATUS_CH0F   (0U)          //!< Bit position for TPM_STATUS_CH0F.
#define BM_TPM_STATUS_CH0F   (0x00000001U) //!< Bit mask for TPM_STATUS_CH0F.
#define BS_TPM_STATUS_CH0F   (1U)          //!< Bit field size in bits for TPM_STATUS_CH0F.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_STATUS_CH0F field.
#define BR_TPM_STATUS_CH0F(x) (BME_UBFX32(HW_TPM_STATUS_ADDR(x), BP_TPM_STATUS_CH0F, BS_TPM_STATUS_CH0F))
#endif

//! @brief Format value for bitfield TPM_STATUS_CH0F.
#define BF_TPM_STATUS_CH0F(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_STATUS_CH0F), uint32_t) & BM_TPM_STATUS_CH0F)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CH0F field to a new value.
#define BW_TPM_STATUS_CH0F(x, v) (BME_BFI32(HW_TPM_STATUS_ADDR(x), ((uint32_t)(v) << BP_TPM_STATUS_CH0F), BP_TPM_STATUS_CH0F, 1))
#endif
//@}

/*!
 * @name Register TPM_STATUS, field CH1F[1] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
//@{
#define BP_TPM_STATUS_CH1F   (1U)          //!< Bit position for TPM_STATUS_CH1F.
#define BM_TPM_STATUS_CH1F   (0x00000002U) //!< Bit mask for TPM_STATUS_CH1F.
#define BS_TPM_STATUS_CH1F   (1U)          //!< Bit field size in bits for TPM_STATUS_CH1F.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_STATUS_CH1F field.
#define BR_TPM_STATUS_CH1F(x) (BME_UBFX32(HW_TPM_STATUS_ADDR(x), BP_TPM_STATUS_CH1F, BS_TPM_STATUS_CH1F))
#endif

//! @brief Format value for bitfield TPM_STATUS_CH1F.
#define BF_TPM_STATUS_CH1F(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_STATUS_CH1F), uint32_t) & BM_TPM_STATUS_CH1F)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CH1F field to a new value.
#define BW_TPM_STATUS_CH1F(x, v) (BME_BFI32(HW_TPM_STATUS_ADDR(x), ((uint32_t)(v) << BP_TPM_STATUS_CH1F), BP_TPM_STATUS_CH1F, 1))
#endif
//@}

/*!
 * @name Register TPM_STATUS, field CH2F[2] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
//@{
#define BP_TPM_STATUS_CH2F   (2U)          //!< Bit position for TPM_STATUS_CH2F.
#define BM_TPM_STATUS_CH2F   (0x00000004U) //!< Bit mask for TPM_STATUS_CH2F.
#define BS_TPM_STATUS_CH2F   (1U)          //!< Bit field size in bits for TPM_STATUS_CH2F.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_STATUS_CH2F field.
#define BR_TPM_STATUS_CH2F(x) (BME_UBFX32(HW_TPM_STATUS_ADDR(x), BP_TPM_STATUS_CH2F, BS_TPM_STATUS_CH2F))
#endif

//! @brief Format value for bitfield TPM_STATUS_CH2F.
#define BF_TPM_STATUS_CH2F(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_STATUS_CH2F), uint32_t) & BM_TPM_STATUS_CH2F)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CH2F field to a new value.
#define BW_TPM_STATUS_CH2F(x, v) (BME_BFI32(HW_TPM_STATUS_ADDR(x), ((uint32_t)(v) << BP_TPM_STATUS_CH2F), BP_TPM_STATUS_CH2F, 1))
#endif
//@}

/*!
 * @name Register TPM_STATUS, field CH3F[3] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
//@{
#define BP_TPM_STATUS_CH3F   (3U)          //!< Bit position for TPM_STATUS_CH3F.
#define BM_TPM_STATUS_CH3F   (0x00000008U) //!< Bit mask for TPM_STATUS_CH3F.
#define BS_TPM_STATUS_CH3F   (1U)          //!< Bit field size in bits for TPM_STATUS_CH3F.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_STATUS_CH3F field.
#define BR_TPM_STATUS_CH3F(x) (BME_UBFX32(HW_TPM_STATUS_ADDR(x), BP_TPM_STATUS_CH3F, BS_TPM_STATUS_CH3F))
#endif

//! @brief Format value for bitfield TPM_STATUS_CH3F.
#define BF_TPM_STATUS_CH3F(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_STATUS_CH3F), uint32_t) & BM_TPM_STATUS_CH3F)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CH3F field to a new value.
#define BW_TPM_STATUS_CH3F(x, v) (BME_BFI32(HW_TPM_STATUS_ADDR(x), ((uint32_t)(v) << BP_TPM_STATUS_CH3F), BP_TPM_STATUS_CH3F, 1))
#endif
//@}

/*!
 * @name Register TPM_STATUS, field CH4F[4] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
//@{
#define BP_TPM_STATUS_CH4F   (4U)          //!< Bit position for TPM_STATUS_CH4F.
#define BM_TPM_STATUS_CH4F   (0x00000010U) //!< Bit mask for TPM_STATUS_CH4F.
#define BS_TPM_STATUS_CH4F   (1U)          //!< Bit field size in bits for TPM_STATUS_CH4F.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_STATUS_CH4F field.
#define BR_TPM_STATUS_CH4F(x) (BME_UBFX32(HW_TPM_STATUS_ADDR(x), BP_TPM_STATUS_CH4F, BS_TPM_STATUS_CH4F))
#endif

//! @brief Format value for bitfield TPM_STATUS_CH4F.
#define BF_TPM_STATUS_CH4F(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_STATUS_CH4F), uint32_t) & BM_TPM_STATUS_CH4F)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CH4F field to a new value.
#define BW_TPM_STATUS_CH4F(x, v) (BME_BFI32(HW_TPM_STATUS_ADDR(x), ((uint32_t)(v) << BP_TPM_STATUS_CH4F), BP_TPM_STATUS_CH4F, 1))
#endif
//@}

/*!
 * @name Register TPM_STATUS, field CH5F[5] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
//@{
#define BP_TPM_STATUS_CH5F   (5U)          //!< Bit position for TPM_STATUS_CH5F.
#define BM_TPM_STATUS_CH5F   (0x00000020U) //!< Bit mask for TPM_STATUS_CH5F.
#define BS_TPM_STATUS_CH5F   (1U)          //!< Bit field size in bits for TPM_STATUS_CH5F.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_STATUS_CH5F field.
#define BR_TPM_STATUS_CH5F(x) (BME_UBFX32(HW_TPM_STATUS_ADDR(x), BP_TPM_STATUS_CH5F, BS_TPM_STATUS_CH5F))
#endif

//! @brief Format value for bitfield TPM_STATUS_CH5F.
#define BF_TPM_STATUS_CH5F(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_STATUS_CH5F), uint32_t) & BM_TPM_STATUS_CH5F)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CH5F field to a new value.
#define BW_TPM_STATUS_CH5F(x, v) (BME_BFI32(HW_TPM_STATUS_ADDR(x), ((uint32_t)(v) << BP_TPM_STATUS_CH5F), BP_TPM_STATUS_CH5F, 1))
#endif
//@}

/*!
 * @name Register TPM_STATUS, field TOF[8] (W1C)
 *
 * See register description
 *
 * Values:
 * - 0 - LPTPM counter has not overflowed.
 * - 1 - LPTPM counter has overflowed.
 */
//@{
#define BP_TPM_STATUS_TOF    (8U)          //!< Bit position for TPM_STATUS_TOF.
#define BM_TPM_STATUS_TOF    (0x00000100U) //!< Bit mask for TPM_STATUS_TOF.
#define BS_TPM_STATUS_TOF    (1U)          //!< Bit field size in bits for TPM_STATUS_TOF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_STATUS_TOF field.
#define BR_TPM_STATUS_TOF(x) (BME_UBFX32(HW_TPM_STATUS_ADDR(x), BP_TPM_STATUS_TOF, BS_TPM_STATUS_TOF))
#endif

//! @brief Format value for bitfield TPM_STATUS_TOF.
#define BF_TPM_STATUS_TOF(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_STATUS_TOF), uint32_t) & BM_TPM_STATUS_TOF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TOF field to a new value.
#define BW_TPM_STATUS_TOF(x, v) (BME_BFI32(HW_TPM_STATUS_ADDR(x), ((uint32_t)(v) << BP_TPM_STATUS_TOF), BP_TPM_STATUS_TOF, 1))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_TPM_CONF - Configuration
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_TPM_CONF - Configuration (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the behavior in debug and wait modes and the use of an
 * external global time base.
 */
typedef union _hw_tpm_conf
{
    uint32_t U;
    struct _hw_tpm_conf_bitfields
    {
        uint32_t RESERVED0 : 5;        //!< [4:0]
        uint32_t DOZEEN : 1;           //!< [5] Doze Enable
        uint32_t DBGMODE : 2;          //!< [7:6] Debug Mode
        uint32_t RESERVED1 : 1;        //!< [8]
        uint32_t GTBEEN : 1;           //!< [9] Global time base enable
        uint32_t RESERVED2 : 6;        //!< [15:10]
        uint32_t CSOT : 1;             //!< [16] Counter Start on Trigger
        uint32_t CSOO : 1;             //!< [17] Counter Stop On Overflow
        uint32_t CROT : 1;             //!< [18] Counter Reload On Trigger
        uint32_t RESERVED3 : 5;        //!< [23:19]
        uint32_t TRGSEL : 4;           //!< [27:24] Trigger Select
        uint32_t RESERVED4 : 4;        //!< [31:28]
    } B;
} hw_tpm_conf_t;
#endif

/*!
 * @name Constants and macros for entire TPM_CONF register
 */
//@{
#define HW_TPM_CONF_ADDR(x)      (REGS_TPM_BASE(x) + 0x84U)

#ifndef __LANGUAGE_ASM__
#define HW_TPM_CONF(x)           (*(__IO hw_tpm_conf_t *) HW_TPM_CONF_ADDR(x))
#define HW_TPM_CONF_RD(x)        (HW_TPM_CONF(x).U)
#define HW_TPM_CONF_WR(x, v)     (HW_TPM_CONF(x).U = (v))
#define HW_TPM_CONF_SET(x, v)    (BME_OR32(HW_TPM_CONF_ADDR(x), (uint32_t)(v)))
#define HW_TPM_CONF_CLR(x, v)    (BME_AND32(HW_TPM_CONF_ADDR(x), (uint32_t)(~(v))))
#define HW_TPM_CONF_TOG(x, v)    (BME_XOR32(HW_TPM_CONF_ADDR(x), (uint32_t)(v)))
#endif
//@}

/*
 * Constants & macros for individual TPM_CONF bitfields
 */

/*!
 * @name Register TPM_CONF, field DOZEEN[5] (RW)
 *
 * Configures the LPTPM behavior in wait mode.
 *
 * Values:
 * - 0 - Internal LPTPM counter continues in Doze mode.
 * - 1 - Internal LPTPM counter is paused and does not increment during Doze
 *     mode. Trigger inputs and input capture events are also ignored.
 */
//@{
#define BP_TPM_CONF_DOZEEN   (5U)          //!< Bit position for TPM_CONF_DOZEEN.
#define BM_TPM_CONF_DOZEEN   (0x00000020U) //!< Bit mask for TPM_CONF_DOZEEN.
#define BS_TPM_CONF_DOZEEN   (1U)          //!< Bit field size in bits for TPM_CONF_DOZEEN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_CONF_DOZEEN field.
#define BR_TPM_CONF_DOZEEN(x) (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_DOZEEN, BS_TPM_CONF_DOZEEN))
#endif

//! @brief Format value for bitfield TPM_CONF_DOZEEN.
#define BF_TPM_CONF_DOZEEN(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_CONF_DOZEEN), uint32_t) & BM_TPM_CONF_DOZEEN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DOZEEN field to a new value.
#define BW_TPM_CONF_DOZEEN(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_DOZEEN), BP_TPM_CONF_DOZEEN, 1))
#endif
//@}

/*!
 * @name Register TPM_CONF, field DBGMODE[7:6] (RW)
 *
 * Configures the LPTPM behavior in debug mode. All other configurations are
 * reserved.
 *
 * Values:
 * - 00 - LPTPM counter is paused and does not increment during debug mode.
 *     Trigger inputs and input capture events are also ignored.
 * - 11 - LPTPM counter continues in debug mode.
 */
//@{
#define BP_TPM_CONF_DBGMODE  (6U)          //!< Bit position for TPM_CONF_DBGMODE.
#define BM_TPM_CONF_DBGMODE  (0x000000C0U) //!< Bit mask for TPM_CONF_DBGMODE.
#define BS_TPM_CONF_DBGMODE  (2U)          //!< Bit field size in bits for TPM_CONF_DBGMODE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_CONF_DBGMODE field.
#define BR_TPM_CONF_DBGMODE(x) (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_DBGMODE, BS_TPM_CONF_DBGMODE))
#endif

//! @brief Format value for bitfield TPM_CONF_DBGMODE.
#define BF_TPM_CONF_DBGMODE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_CONF_DBGMODE), uint32_t) & BM_TPM_CONF_DBGMODE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DBGMODE field to a new value.
#define BW_TPM_CONF_DBGMODE(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_DBGMODE), BP_TPM_CONF_DBGMODE, 2))
#endif
//@}

/*!
 * @name Register TPM_CONF, field GTBEEN[9] (RW)
 *
 * Configures the LPTPM to use an externally generated global time base counter.
 * When an externally generated timebase is used, the internal LPTPM counter is
 * not used by the channels but can be used to generate a periodic interrupt or
 * DMA request using the Modulo register and timer overflow flag.
 *
 * Values:
 * - 0 - All channels use the internally generated LPTPM counter as their
 *     timebase
 * - 1 - All channels use an externally generated global timebase as their
 *     timebase
 */
//@{
#define BP_TPM_CONF_GTBEEN   (9U)          //!< Bit position for TPM_CONF_GTBEEN.
#define BM_TPM_CONF_GTBEEN   (0x00000200U) //!< Bit mask for TPM_CONF_GTBEEN.
#define BS_TPM_CONF_GTBEEN   (1U)          //!< Bit field size in bits for TPM_CONF_GTBEEN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_CONF_GTBEEN field.
#define BR_TPM_CONF_GTBEEN(x) (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_GTBEEN, BS_TPM_CONF_GTBEEN))
#endif

//! @brief Format value for bitfield TPM_CONF_GTBEEN.
#define BF_TPM_CONF_GTBEEN(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_CONF_GTBEEN), uint32_t) & BM_TPM_CONF_GTBEEN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the GTBEEN field to a new value.
#define BW_TPM_CONF_GTBEEN(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_GTBEEN), BP_TPM_CONF_GTBEEN, 1))
#endif
//@}

/*!
 * @name Register TPM_CONF, field CSOT[16] (RW)
 *
 * When set, the LPTPM counter will not start incrementing after it is enabled
 * until a rising edge on the selected trigger input is detected. If the LPTPM
 * counter is stopped due to an overflow, a rising edge on the selected trigger
 * input will also cause the LPTPM counter to start incrementing again. The trigger
 * input is ignored if the LPTPM counter is paused during debug mode or doze mode.
 * This field should only be changed when the LPTPM counter is disabled.
 *
 * Values:
 * - 0 - LPTPM counter starts to increment immediately, once it is enabled.
 * - 1 - LPTPM counter only starts to increment when it a rising edge on the
 *     selected input trigger is detected, after it has been enabled or after it has
 *     stopped due to overflow.
 */
//@{
#define BP_TPM_CONF_CSOT     (16U)         //!< Bit position for TPM_CONF_CSOT.
#define BM_TPM_CONF_CSOT     (0x00010000U) //!< Bit mask for TPM_CONF_CSOT.
#define BS_TPM_CONF_CSOT     (1U)          //!< Bit field size in bits for TPM_CONF_CSOT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_CONF_CSOT field.
#define BR_TPM_CONF_CSOT(x)  (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_CSOT, BS_TPM_CONF_CSOT))
#endif

//! @brief Format value for bitfield TPM_CONF_CSOT.
#define BF_TPM_CONF_CSOT(v)  (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_CONF_CSOT), uint32_t) & BM_TPM_CONF_CSOT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CSOT field to a new value.
#define BW_TPM_CONF_CSOT(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_CSOT), BP_TPM_CONF_CSOT, 1))
#endif
//@}

/*!
 * @name Register TPM_CONF, field CSOO[17] (RW)
 *
 * When set, the LPTPM counter will stop incrementing once the counter equals
 * the MOD value and incremented (this also sets the TOF). Reloading the counter
 * with zero due to writing to the counter register or due to a trigger input does
 * not cause the counter to stop incrementing. Once the counter has stopped
 * incrementing, the counter will not start incrementing unless it is disabled and
 * then enabled again, or a rising edge on the selected trigger input is detected
 * when CSOT set. This field should only be changed when the LPTPM counter is
 * disabled.
 *
 * Values:
 * - 0 - LPTPM counter continues incrementing or decrementing after overflow
 * - 1 - LPTPM counter stops incrementing or decrementing after overflow.
 */
//@{
#define BP_TPM_CONF_CSOO     (17U)         //!< Bit position for TPM_CONF_CSOO.
#define BM_TPM_CONF_CSOO     (0x00020000U) //!< Bit mask for TPM_CONF_CSOO.
#define BS_TPM_CONF_CSOO     (1U)          //!< Bit field size in bits for TPM_CONF_CSOO.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_CONF_CSOO field.
#define BR_TPM_CONF_CSOO(x)  (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_CSOO, BS_TPM_CONF_CSOO))
#endif

//! @brief Format value for bitfield TPM_CONF_CSOO.
#define BF_TPM_CONF_CSOO(v)  (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_CONF_CSOO), uint32_t) & BM_TPM_CONF_CSOO)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CSOO field to a new value.
#define BW_TPM_CONF_CSOO(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_CSOO), BP_TPM_CONF_CSOO, 1))
#endif
//@}

/*!
 * @name Register TPM_CONF, field CROT[18] (RW)
 *
 * When set, the LPTPM counter will reload with zero (and initialize PWM outputs
 * to their default value) when a rising edge is detected on the selected
 * trigger input. The trigger input is ignored if the LPTPM counter is paused during
 * debug mode or doze mode. This field should only be changed when the LPTPM
 * counter is disabled.
 *
 * Values:
 * - 0 - Counter is not reloaded due to a rising edge on the selected input
 *     trigger
 * - 1 - Counter is reloaded when a rising edge is detected on the selected
 *     input trigger
 */
//@{
#define BP_TPM_CONF_CROT     (18U)         //!< Bit position for TPM_CONF_CROT.
#define BM_TPM_CONF_CROT     (0x00040000U) //!< Bit mask for TPM_CONF_CROT.
#define BS_TPM_CONF_CROT     (1U)          //!< Bit field size in bits for TPM_CONF_CROT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_CONF_CROT field.
#define BR_TPM_CONF_CROT(x)  (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_CROT, BS_TPM_CONF_CROT))
#endif

//! @brief Format value for bitfield TPM_CONF_CROT.
#define BF_TPM_CONF_CROT(v)  (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_CONF_CROT), uint32_t) & BM_TPM_CONF_CROT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CROT field to a new value.
#define BW_TPM_CONF_CROT(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_CROT), BP_TPM_CONF_CROT, 1))
#endif
//@}

/*!
 * @name Register TPM_CONF, field TRGSEL[27:24] (RW)
 *
 * Selects the input trigger to use for starting the counter and/or reloading
 * the counter. This field should only be changed when the LPTPM counter is
 * disabled. See Chip configuration section for available options.
 */
//@{
#define BP_TPM_CONF_TRGSEL   (24U)         //!< Bit position for TPM_CONF_TRGSEL.
#define BM_TPM_CONF_TRGSEL   (0x0F000000U) //!< Bit mask for TPM_CONF_TRGSEL.
#define BS_TPM_CONF_TRGSEL   (4U)          //!< Bit field size in bits for TPM_CONF_TRGSEL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the TPM_CONF_TRGSEL field.
#define BR_TPM_CONF_TRGSEL(x) (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_TRGSEL, BS_TPM_CONF_TRGSEL))
#endif

//! @brief Format value for bitfield TPM_CONF_TRGSEL.
#define BF_TPM_CONF_TRGSEL(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_TPM_CONF_TRGSEL), uint32_t) & BM_TPM_CONF_TRGSEL)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TRGSEL field to a new value.
#define BW_TPM_CONF_TRGSEL(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_TRGSEL), BP_TPM_CONF_TRGSEL, 4))
#endif
//@}

//-------------------------------------------------------------------------------------------
// hw_tpm_t - module struct
//-------------------------------------------------------------------------------------------
/*!
 * @brief All TPM module registers.
 */
#ifndef __LANGUAGE_ASM__
#pragma pack(1)
typedef struct _hw_tpm
{
    __IO hw_tpm_sc_t SC;                   //!< [0x0] Status and Control
    __IO hw_tpm_cnt_t CNT;                 //!< [0x4] Counter
    __IO hw_tpm_mod_t MOD;                 //!< [0x8] Modulo
    struct {
        __IO hw_tpm_cnsc_t CnSC;           //!< [0xC] Channel (n) Status and Control
        __IO hw_tpm_cnv_t CnV;             //!< [0x10] Channel (n) Value
    } CONTROLS[6];
    uint8_t _reserved0[20];
    __IO hw_tpm_status_t STATUS;           //!< [0x50] Capture and Compare Status
    uint8_t _reserved1[48];
    __IO hw_tpm_conf_t CONF;               //!< [0x84] Configuration
} hw_tpm_t;
#pragma pack()

//! @brief Macro to access all TPM registers.
//! @param x TPM instance number.
//! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
//!     use the '&' operator, like <code>&HW_TPM(0)</code>.
#define HW_TPM(x)      (*(hw_tpm_t *) REGS_TPM_BASE(x))
#endif

#endif // __HW_TPM_REGISTERS_H__
// v22/130726/0.9
// EOF

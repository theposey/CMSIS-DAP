/*
 * Copyright (c) 2014, Freescale Semiconductor, Inc.
 * All rights reserved.
 *
 * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL FREESCALE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */
/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_NFC_REGISTERS_H__
#define __HW_NFC_REGISTERS_H__

#include "regs.h"

/*
 * MK70F12 NFC
 *
 * NAND flash controller
 *
 * Registers defined in this header file:
 * - HW_NFC_CMD1 - Flash command 1
 * - HW_NFC_CMD2 - Flash command 2
 * - HW_NFC_CAR - Column address
 * - HW_NFC_RAR - Row address
 * - HW_NFC_RPT - Flash command repeat
 * - HW_NFC_RAI - Row address increment
 * - HW_NFC_SR1 - Flash status 1
 * - HW_NFC_SR2 - Flash status 2
 * - HW_NFC_DMA1 - DMA channel 1 address
 * - HW_NFC_DMACFG - DMA configuration
 * - HW_NFC_SWAP - Cach swap
 * - HW_NFC_SECSZ - Sector size
 * - HW_NFC_CFG - Flash configuration
 * - HW_NFC_DMA2 - DMA channel 2 address
 * - HW_NFC_ISR - Interrupt status
 *
 * - hw_nfc_t - Struct containing all module registers.
 */

//! @name Module base addresses
//@{
#ifndef REGS_NFC_BASE
#define HW_NFC_INSTANCE_COUNT (1U) //!< Number of instances of the NFC module.
#define REGS_NFC_BASE (0x400A8000U) //!< Base address for NFC.
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_NFC_CMD1 - Flash command 1
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_NFC_CMD1 - Flash command 1 (RW)
 *
 * Reset value: 0x30FF0000U
 */
typedef union _hw_nfc_cmd1
{
    uint32_t U;
    struct _hw_nfc_cmd1_bitfields
    {
        uint32_t RESERVED0 : 16;       //!< [15:0]
        uint32_t BYTE3 : 8;            //!< [23:16] Third command byte that may be sent
                                       //! to the flash device
        uint32_t BYTE2 : 8;            //!< [31:24] Second command byte that may be sent
                                       //! to the flash device
    } B;
} hw_nfc_cmd1_t;
#endif

/*!
 * @name Constants and macros for entire NFC_CMD1 register
 */
//@{
#define HW_NFC_CMD1_ADDR         (REGS_NFC_BASE + 0x3F00U)

#ifndef __LANGUAGE_ASM__
#define HW_NFC_CMD1              (*(__IO hw_nfc_cmd1_t *) HW_NFC_CMD1_ADDR)
#define HW_NFC_CMD1_RD()         (HW_NFC_CMD1.U)
#define HW_NFC_CMD1_WR(v)        (HW_NFC_CMD1.U = (v))
#define HW_NFC_CMD1_SET(v)       (HW_NFC_CMD1_WR(HW_NFC_CMD1_RD() |  (v)))
#define HW_NFC_CMD1_CLR(v)       (HW_NFC_CMD1_WR(HW_NFC_CMD1_RD() & ~(v)))
#define HW_NFC_CMD1_TOG(v)       (HW_NFC_CMD1_WR(HW_NFC_CMD1_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual NFC_CMD1 bitfields
 */

/*!
 * @name Register NFC_CMD1, field BYTE3[23:16] (RW)
 */
//@{
#define BP_NFC_CMD1_BYTE3    (16U)         //!< Bit position for NFC_CMD1_BYTE3.
#define BM_NFC_CMD1_BYTE3    (0x00FF0000U) //!< Bit mask for NFC_CMD1_BYTE3.
#define BS_NFC_CMD1_BYTE3    (8U)          //!< Bit field size in bits for NFC_CMD1_BYTE3.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_CMD1_BYTE3 field.
#define BR_NFC_CMD1_BYTE3    (HW_NFC_CMD1.B.BYTE3)
#endif

//! @brief Format value for bitfield NFC_CMD1_BYTE3.
#define BF_NFC_CMD1_BYTE3(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_CMD1_BYTE3), uint32_t) & BM_NFC_CMD1_BYTE3)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BYTE3 field to a new value.
#define BW_NFC_CMD1_BYTE3(v) (HW_NFC_CMD1_WR((HW_NFC_CMD1_RD() & ~BM_NFC_CMD1_BYTE3) | BF_NFC_CMD1_BYTE3(v)))
#endif
//@}

/*!
 * @name Register NFC_CMD1, field BYTE2[31:24] (RW)
 */
//@{
#define BP_NFC_CMD1_BYTE2    (24U)         //!< Bit position for NFC_CMD1_BYTE2.
#define BM_NFC_CMD1_BYTE2    (0xFF000000U) //!< Bit mask for NFC_CMD1_BYTE2.
#define BS_NFC_CMD1_BYTE2    (8U)          //!< Bit field size in bits for NFC_CMD1_BYTE2.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_CMD1_BYTE2 field.
#define BR_NFC_CMD1_BYTE2    (HW_NFC_CMD1.B.BYTE2)
#endif

//! @brief Format value for bitfield NFC_CMD1_BYTE2.
#define BF_NFC_CMD1_BYTE2(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_CMD1_BYTE2), uint32_t) & BM_NFC_CMD1_BYTE2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BYTE2 field to a new value.
#define BW_NFC_CMD1_BYTE2(v) (HW_NFC_CMD1_WR((HW_NFC_CMD1_RD() & ~BM_NFC_CMD1_BYTE2) | BF_NFC_CMD1_BYTE2(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_NFC_CMD2 - Flash command 2
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_NFC_CMD2 - Flash command 2 (RW)
 *
 * Reset value: 0x007EE000U
 */
typedef union _hw_nfc_cmd2
{
    uint32_t U;
    struct _hw_nfc_cmd2_bitfields
    {
        uint32_t BUSY_START : 1;       //!< [0] Busy indicator and start command
        uint32_t BUFNO : 2;            //!< [2:1] Internal buffer number used for this
                                       //! command
        uint32_t RESERVED0 : 5;        //!< [7:3]
        uint32_t CODE : 16;            //!< [23:8] User-defined flash operation sequencer
        uint32_t BYTE1 : 8;            //!< [31:24] First command byte that may be sent
                                       //! to the flash device
    } B;
} hw_nfc_cmd2_t;
#endif

/*!
 * @name Constants and macros for entire NFC_CMD2 register
 */
//@{
#define HW_NFC_CMD2_ADDR         (REGS_NFC_BASE + 0x3F04U)

#ifndef __LANGUAGE_ASM__
#define HW_NFC_CMD2              (*(__IO hw_nfc_cmd2_t *) HW_NFC_CMD2_ADDR)
#define HW_NFC_CMD2_RD()         (HW_NFC_CMD2.U)
#define HW_NFC_CMD2_WR(v)        (HW_NFC_CMD2.U = (v))
#define HW_NFC_CMD2_SET(v)       (HW_NFC_CMD2_WR(HW_NFC_CMD2_RD() |  (v)))
#define HW_NFC_CMD2_CLR(v)       (HW_NFC_CMD2_WR(HW_NFC_CMD2_RD() & ~(v)))
#define HW_NFC_CMD2_TOG(v)       (HW_NFC_CMD2_WR(HW_NFC_CMD2_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual NFC_CMD2 bitfields
 */

/*!
 * @name Register NFC_CMD2, field BUSY_START[0] (RW)
 *
 * This busy indicator is repeated in the NFC_ISR register. Read to this
 * bitfield indicates BUSY whereas write indicates START.
 *
 * Values:
 * - 0 - During reads, flash controller is idle and it is okay to send next
 *     command. During writes, no action.
 * - 1 - During reads, command execution is busy. During writes, start command
 *     execution.
 */
//@{
#define BP_NFC_CMD2_BUSY_START (0U)        //!< Bit position for NFC_CMD2_BUSY_START.
#define BM_NFC_CMD2_BUSY_START (0x00000001U) //!< Bit mask for NFC_CMD2_BUSY_START.
#define BS_NFC_CMD2_BUSY_START (1U)        //!< Bit field size in bits for NFC_CMD2_BUSY_START.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_CMD2_BUSY_START field.
#define BR_NFC_CMD2_BUSY_START (BITBAND_ACCESS32(HW_NFC_CMD2_ADDR, BP_NFC_CMD2_BUSY_START))
#endif

//! @brief Format value for bitfield NFC_CMD2_BUSY_START.
#define BF_NFC_CMD2_BUSY_START(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_CMD2_BUSY_START), uint32_t) & BM_NFC_CMD2_BUSY_START)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BUSY_START field to a new value.
#define BW_NFC_CMD2_BUSY_START(v) (BITBAND_ACCESS32(HW_NFC_CMD2_ADDR, BP_NFC_CMD2_BUSY_START) = (v))
#endif
//@}

/*!
 * @name Register NFC_CMD2, field BUFNO[2:1] (RW)
 */
//@{
#define BP_NFC_CMD2_BUFNO    (1U)          //!< Bit position for NFC_CMD2_BUFNO.
#define BM_NFC_CMD2_BUFNO    (0x00000006U) //!< Bit mask for NFC_CMD2_BUFNO.
#define BS_NFC_CMD2_BUFNO    (2U)          //!< Bit field size in bits for NFC_CMD2_BUFNO.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_CMD2_BUFNO field.
#define BR_NFC_CMD2_BUFNO    (HW_NFC_CMD2.B.BUFNO)
#endif

//! @brief Format value for bitfield NFC_CMD2_BUFNO.
#define BF_NFC_CMD2_BUFNO(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_CMD2_BUFNO), uint32_t) & BM_NFC_CMD2_BUFNO)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BUFNO field to a new value.
#define BW_NFC_CMD2_BUFNO(v) (HW_NFC_CMD2_WR((HW_NFC_CMD2_RD() & ~BM_NFC_CMD2_BUFNO) | BF_NFC_CMD2_BUFNO(v)))
#endif
//@}

/*!
 * @name Register NFC_CMD2, field CODE[23:8] (RW)
 *
 * Each bit indicates a certain action. If the bit is set, the corresponding
 * action is executed after writing 1 to START. The following are some configuration
 * examples (other sequences are possible):
 */
//@{
#define BP_NFC_CMD2_CODE     (8U)          //!< Bit position for NFC_CMD2_CODE.
#define BM_NFC_CMD2_CODE     (0x00FFFF00U) //!< Bit mask for NFC_CMD2_CODE.
#define BS_NFC_CMD2_CODE     (16U)         //!< Bit field size in bits for NFC_CMD2_CODE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_CMD2_CODE field.
#define BR_NFC_CMD2_CODE     (HW_NFC_CMD2.B.CODE)
#endif

//! @brief Format value for bitfield NFC_CMD2_CODE.
#define BF_NFC_CMD2_CODE(v)  (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_CMD2_CODE), uint32_t) & BM_NFC_CMD2_CODE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CODE field to a new value.
#define BW_NFC_CMD2_CODE(v)  (HW_NFC_CMD2_WR((HW_NFC_CMD2_RD() & ~BM_NFC_CMD2_CODE) | BF_NFC_CMD2_CODE(v)))
#endif
//@}

/*!
 * @name Register NFC_CMD2, field BYTE1[31:24] (RW)
 */
//@{
#define BP_NFC_CMD2_BYTE1    (24U)         //!< Bit position for NFC_CMD2_BYTE1.
#define BM_NFC_CMD2_BYTE1    (0xFF000000U) //!< Bit mask for NFC_CMD2_BYTE1.
#define BS_NFC_CMD2_BYTE1    (8U)          //!< Bit field size in bits for NFC_CMD2_BYTE1.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_CMD2_BYTE1 field.
#define BR_NFC_CMD2_BYTE1    (HW_NFC_CMD2.B.BYTE1)
#endif

//! @brief Format value for bitfield NFC_CMD2_BYTE1.
#define BF_NFC_CMD2_BYTE1(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_CMD2_BYTE1), uint32_t) & BM_NFC_CMD2_BYTE1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BYTE1 field to a new value.
#define BW_NFC_CMD2_BYTE1(v) (HW_NFC_CMD2_WR((HW_NFC_CMD2_RD() & ~BM_NFC_CMD2_BYTE1) | BF_NFC_CMD2_BYTE1(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_NFC_CAR - Column address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_NFC_CAR - Column address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_nfc_car
{
    uint32_t U;
    struct _hw_nfc_car_bitfields
    {
        uint32_t BYTE1 : 8;            //!< [7:0] First byte of column address
        uint32_t BYTE2 : 8;            //!< [15:8] Second byte of column address
        uint32_t RESERVED0 : 16;       //!< [31:16]
    } B;
} hw_nfc_car_t;
#endif

/*!
 * @name Constants and macros for entire NFC_CAR register
 */
//@{
#define HW_NFC_CAR_ADDR          (REGS_NFC_BASE + 0x3F08U)

#ifndef __LANGUAGE_ASM__
#define HW_NFC_CAR               (*(__IO hw_nfc_car_t *) HW_NFC_CAR_ADDR)
#define HW_NFC_CAR_RD()          (HW_NFC_CAR.U)
#define HW_NFC_CAR_WR(v)         (HW_NFC_CAR.U = (v))
#define HW_NFC_CAR_SET(v)        (HW_NFC_CAR_WR(HW_NFC_CAR_RD() |  (v)))
#define HW_NFC_CAR_CLR(v)        (HW_NFC_CAR_WR(HW_NFC_CAR_RD() & ~(v)))
#define HW_NFC_CAR_TOG(v)        (HW_NFC_CAR_WR(HW_NFC_CAR_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual NFC_CAR bitfields
 */

/*!
 * @name Register NFC_CAR, field BYTE1[7:0] (RW)
 */
//@{
#define BP_NFC_CAR_BYTE1     (0U)          //!< Bit position for NFC_CAR_BYTE1.
#define BM_NFC_CAR_BYTE1     (0x000000FFU) //!< Bit mask for NFC_CAR_BYTE1.
#define BS_NFC_CAR_BYTE1     (8U)          //!< Bit field size in bits for NFC_CAR_BYTE1.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_CAR_BYTE1 field.
#define BR_NFC_CAR_BYTE1     (HW_NFC_CAR.B.BYTE1)
#endif

//! @brief Format value for bitfield NFC_CAR_BYTE1.
#define BF_NFC_CAR_BYTE1(v)  (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_CAR_BYTE1), uint32_t) & BM_NFC_CAR_BYTE1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BYTE1 field to a new value.
#define BW_NFC_CAR_BYTE1(v)  (HW_NFC_CAR_WR((HW_NFC_CAR_RD() & ~BM_NFC_CAR_BYTE1) | BF_NFC_CAR_BYTE1(v)))
#endif
//@}

/*!
 * @name Register NFC_CAR, field BYTE2[15:8] (RW)
 */
//@{
#define BP_NFC_CAR_BYTE2     (8U)          //!< Bit position for NFC_CAR_BYTE2.
#define BM_NFC_CAR_BYTE2     (0x0000FF00U) //!< Bit mask for NFC_CAR_BYTE2.
#define BS_NFC_CAR_BYTE2     (8U)          //!< Bit field size in bits for NFC_CAR_BYTE2.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_CAR_BYTE2 field.
#define BR_NFC_CAR_BYTE2     (HW_NFC_CAR.B.BYTE2)
#endif

//! @brief Format value for bitfield NFC_CAR_BYTE2.
#define BF_NFC_CAR_BYTE2(v)  (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_CAR_BYTE2), uint32_t) & BM_NFC_CAR_BYTE2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BYTE2 field to a new value.
#define BW_NFC_CAR_BYTE2(v)  (HW_NFC_CAR_WR((HW_NFC_CAR_RD() & ~BM_NFC_CAR_BYTE2) | BF_NFC_CAR_BYTE2(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_NFC_RAR - Row address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_NFC_RAR - Row address (RW)
 *
 * Reset value: 0x11000000U
 */
typedef union _hw_nfc_rar
{
    uint32_t U;
    struct _hw_nfc_rar_bitfields
    {
        uint32_t BYTE1 : 8;            //!< [7:0] First byte of row address
        uint32_t BYTE2 : 8;            //!< [15:8] Second byte of row address
        uint32_t BYTE3 : 8;            //!< [23:16] Third byte of row address
        uint32_t RB0 : 1;              //!< [24] Ready/busy 0 enable
        uint32_t RB1 : 1;              //!< [25] Ready/busy 1 enable
        uint32_t RESERVED0 : 2;        //!< [27:26]
        uint32_t CS0 : 1;              //!< [28] Chip select 0 enable
        uint32_t CS1 : 1;              //!< [29] Chip select 1 enable
        uint32_t RESERVED1 : 2;        //!< [31:30]
    } B;
} hw_nfc_rar_t;
#endif

/*!
 * @name Constants and macros for entire NFC_RAR register
 */
//@{
#define HW_NFC_RAR_ADDR          (REGS_NFC_BASE + 0x3F0CU)

#ifndef __LANGUAGE_ASM__
#define HW_NFC_RAR               (*(__IO hw_nfc_rar_t *) HW_NFC_RAR_ADDR)
#define HW_NFC_RAR_RD()          (HW_NFC_RAR.U)
#define HW_NFC_RAR_WR(v)         (HW_NFC_RAR.U = (v))
#define HW_NFC_RAR_SET(v)        (HW_NFC_RAR_WR(HW_NFC_RAR_RD() |  (v)))
#define HW_NFC_RAR_CLR(v)        (HW_NFC_RAR_WR(HW_NFC_RAR_RD() & ~(v)))
#define HW_NFC_RAR_TOG(v)        (HW_NFC_RAR_WR(HW_NFC_RAR_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual NFC_RAR bitfields
 */

/*!
 * @name Register NFC_RAR, field BYTE1[7:0] (RW)
 */
//@{
#define BP_NFC_RAR_BYTE1     (0U)          //!< Bit position for NFC_RAR_BYTE1.
#define BM_NFC_RAR_BYTE1     (0x000000FFU) //!< Bit mask for NFC_RAR_BYTE1.
#define BS_NFC_RAR_BYTE1     (8U)          //!< Bit field size in bits for NFC_RAR_BYTE1.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_RAR_BYTE1 field.
#define BR_NFC_RAR_BYTE1     (HW_NFC_RAR.B.BYTE1)
#endif

//! @brief Format value for bitfield NFC_RAR_BYTE1.
#define BF_NFC_RAR_BYTE1(v)  (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_RAR_BYTE1), uint32_t) & BM_NFC_RAR_BYTE1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BYTE1 field to a new value.
#define BW_NFC_RAR_BYTE1(v)  (HW_NFC_RAR_WR((HW_NFC_RAR_RD() & ~BM_NFC_RAR_BYTE1) | BF_NFC_RAR_BYTE1(v)))
#endif
//@}

/*!
 * @name Register NFC_RAR, field BYTE2[15:8] (RW)
 */
//@{
#define BP_NFC_RAR_BYTE2     (8U)          //!< Bit position for NFC_RAR_BYTE2.
#define BM_NFC_RAR_BYTE2     (0x0000FF00U) //!< Bit mask for NFC_RAR_BYTE2.
#define BS_NFC_RAR_BYTE2     (8U)          //!< Bit field size in bits for NFC_RAR_BYTE2.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_RAR_BYTE2 field.
#define BR_NFC_RAR_BYTE2     (HW_NFC_RAR.B.BYTE2)
#endif

//! @brief Format value for bitfield NFC_RAR_BYTE2.
#define BF_NFC_RAR_BYTE2(v)  (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_RAR_BYTE2), uint32_t) & BM_NFC_RAR_BYTE2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BYTE2 field to a new value.
#define BW_NFC_RAR_BYTE2(v)  (HW_NFC_RAR_WR((HW_NFC_RAR_RD() & ~BM_NFC_RAR_BYTE2) | BF_NFC_RAR_BYTE2(v)))
#endif
//@}

/*!
 * @name Register NFC_RAR, field BYTE3[23:16] (RW)
 */
//@{
#define BP_NFC_RAR_BYTE3     (16U)         //!< Bit position for NFC_RAR_BYTE3.
#define BM_NFC_RAR_BYTE3     (0x00FF0000U) //!< Bit mask for NFC_RAR_BYTE3.
#define BS_NFC_RAR_BYTE3     (8U)          //!< Bit field size in bits for NFC_RAR_BYTE3.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_RAR_BYTE3 field.
#define BR_NFC_RAR_BYTE3     (HW_NFC_RAR.B.BYTE3)
#endif

//! @brief Format value for bitfield NFC_RAR_BYTE3.
#define BF_NFC_RAR_BYTE3(v)  (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_RAR_BYTE3), uint32_t) & BM_NFC_RAR_BYTE3)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BYTE3 field to a new value.
#define BW_NFC_RAR_BYTE3(v)  (HW_NFC_RAR_WR((HW_NFC_RAR_RD() & ~BM_NFC_RAR_BYTE3) | BF_NFC_RAR_BYTE3(v)))
#endif
//@}

/*!
 * @name Register NFC_RAR, field RB0[24] (RW)
 *
 * Determines if NFC_R/ B 0 is waited on a wait for R/ B command. If an equal
 * number of NFC_CE and NFC_R/ B lines are used, the CS n and RB n fields must
 * contain identical values. If only one NFC_R/ B is used, then CS n determines the
 * true chip select, and this field is always 1.
 *
 * Values:
 * - 0 - NFC_R/ B 0 is disabled
 * - 1 - NFC_R/ B 0 is enabled
 */
//@{
#define BP_NFC_RAR_RB0       (24U)         //!< Bit position for NFC_RAR_RB0.
#define BM_NFC_RAR_RB0       (0x01000000U) //!< Bit mask for NFC_RAR_RB0.
#define BS_NFC_RAR_RB0       (1U)          //!< Bit field size in bits for NFC_RAR_RB0.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_RAR_RB0 field.
#define BR_NFC_RAR_RB0       (BITBAND_ACCESS32(HW_NFC_RAR_ADDR, BP_NFC_RAR_RB0))
#endif

//! @brief Format value for bitfield NFC_RAR_RB0.
#define BF_NFC_RAR_RB0(v)    (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_RAR_RB0), uint32_t) & BM_NFC_RAR_RB0)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RB0 field to a new value.
#define BW_NFC_RAR_RB0(v)    (BITBAND_ACCESS32(HW_NFC_RAR_ADDR, BP_NFC_RAR_RB0) = (v))
#endif
//@}

/*!
 * @name Register NFC_RAR, field RB1[25] (RW)
 *
 * Determines if NFC_R/ B 1 is waited on a wait for R/ B command. If an equal
 * number of NFC_CE and NFC_R/ B lines are used, the CS n and RB n fields must
 * contain identical values. If only one NFC_R/ B is used, then CS n determines the
 * true chip select, and this field is always 0.
 *
 * Values:
 * - 0 - NFC_R/ B 1 is disabled
 * - 1 - NFC_R/ B 1 is enabled
 */
//@{
#define BP_NFC_RAR_RB1       (25U)         //!< Bit position for NFC_RAR_RB1.
#define BM_NFC_RAR_RB1       (0x02000000U) //!< Bit mask for NFC_RAR_RB1.
#define BS_NFC_RAR_RB1       (1U)          //!< Bit field size in bits for NFC_RAR_RB1.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_RAR_RB1 field.
#define BR_NFC_RAR_RB1       (BITBAND_ACCESS32(HW_NFC_RAR_ADDR, BP_NFC_RAR_RB1))
#endif

//! @brief Format value for bitfield NFC_RAR_RB1.
#define BF_NFC_RAR_RB1(v)    (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_RAR_RB1), uint32_t) & BM_NFC_RAR_RB1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RB1 field to a new value.
#define BW_NFC_RAR_RB1(v)    (BITBAND_ACCESS32(HW_NFC_RAR_ADDR, BP_NFC_RAR_RB1) = (v))
#endif
//@}

/*!
 * @name Register NFC_RAR, field CS0[28] (RW)
 *
 * Values:
 * - 0 - NFC_CE0 is disabled
 * - 1 - NFC_CE0 is enabled
 */
//@{
#define BP_NFC_RAR_CS0       (28U)         //!< Bit position for NFC_RAR_CS0.
#define BM_NFC_RAR_CS0       (0x10000000U) //!< Bit mask for NFC_RAR_CS0.
#define BS_NFC_RAR_CS0       (1U)          //!< Bit field size in bits for NFC_RAR_CS0.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_RAR_CS0 field.
#define BR_NFC_RAR_CS0       (BITBAND_ACCESS32(HW_NFC_RAR_ADDR, BP_NFC_RAR_CS0))
#endif

//! @brief Format value for bitfield NFC_RAR_CS0.
#define BF_NFC_RAR_CS0(v)    (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_RAR_CS0), uint32_t) & BM_NFC_RAR_CS0)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CS0 field to a new value.
#define BW_NFC_RAR_CS0(v)    (BITBAND_ACCESS32(HW_NFC_RAR_ADDR, BP_NFC_RAR_CS0) = (v))
#endif
//@}

/*!
 * @name Register NFC_RAR, field CS1[29] (RW)
 *
 * Values:
 * - 0 - NFC_CE1 is disabled
 * - 1 - NFC_CE1 is enabled
 */
//@{
#define BP_NFC_RAR_CS1       (29U)         //!< Bit position for NFC_RAR_CS1.
#define BM_NFC_RAR_CS1       (0x20000000U) //!< Bit mask for NFC_RAR_CS1.
#define BS_NFC_RAR_CS1       (1U)          //!< Bit field size in bits for NFC_RAR_CS1.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_RAR_CS1 field.
#define BR_NFC_RAR_CS1       (BITBAND_ACCESS32(HW_NFC_RAR_ADDR, BP_NFC_RAR_CS1))
#endif

//! @brief Format value for bitfield NFC_RAR_CS1.
#define BF_NFC_RAR_CS1(v)    (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_RAR_CS1), uint32_t) & BM_NFC_RAR_CS1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CS1 field to a new value.
#define BW_NFC_RAR_CS1(v)    (BITBAND_ACCESS32(HW_NFC_RAR_ADDR, BP_NFC_RAR_CS1) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_NFC_RPT - Flash command repeat
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_NFC_RPT - Flash command repeat (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_nfc_rpt
{
    uint32_t U;
    struct _hw_nfc_rpt_bitfields
    {
        uint32_t COUNT : 16;           //!< [15:0] 16-bit repeat count
        uint32_t RESERVED0 : 16;       //!< [31:16]
    } B;
} hw_nfc_rpt_t;
#endif

/*!
 * @name Constants and macros for entire NFC_RPT register
 */
//@{
#define HW_NFC_RPT_ADDR          (REGS_NFC_BASE + 0x3F10U)

#ifndef __LANGUAGE_ASM__
#define HW_NFC_RPT               (*(__IO hw_nfc_rpt_t *) HW_NFC_RPT_ADDR)
#define HW_NFC_RPT_RD()          (HW_NFC_RPT.U)
#define HW_NFC_RPT_WR(v)         (HW_NFC_RPT.U = (v))
#define HW_NFC_RPT_SET(v)        (HW_NFC_RPT_WR(HW_NFC_RPT_RD() |  (v)))
#define HW_NFC_RPT_CLR(v)        (HW_NFC_RPT_WR(HW_NFC_RPT_RD() & ~(v)))
#define HW_NFC_RPT_TOG(v)        (HW_NFC_RPT_WR(HW_NFC_RPT_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual NFC_RPT bitfields
 */

/*!
 * @name Register NFC_RPT, field COUNT[15:0] (RW)
 *
 * Determines how many times NFC_CMD2[CODE] is executed. If 0 or 1, the flash
 * command is executed once.
 */
//@{
#define BP_NFC_RPT_COUNT     (0U)          //!< Bit position for NFC_RPT_COUNT.
#define BM_NFC_RPT_COUNT     (0x0000FFFFU) //!< Bit mask for NFC_RPT_COUNT.
#define BS_NFC_RPT_COUNT     (16U)         //!< Bit field size in bits for NFC_RPT_COUNT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_RPT_COUNT field.
#define BR_NFC_RPT_COUNT     (HW_NFC_RPT.B.COUNT)
#endif

//! @brief Format value for bitfield NFC_RPT_COUNT.
#define BF_NFC_RPT_COUNT(v)  (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_RPT_COUNT), uint32_t) & BM_NFC_RPT_COUNT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the COUNT field to a new value.
#define BW_NFC_RPT_COUNT(v)  (HW_NFC_RPT_WR((HW_NFC_RPT_RD() & ~BM_NFC_RPT_COUNT) | BF_NFC_RPT_COUNT(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_NFC_RAI - Row address increment
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_NFC_RAI - Row address increment (RW)
 *
 * Reset value: 0x00000001U
 *
 * When auto-increment of row address is enabled (NFC_CFG[AIAD] = 1), the row
 * address is incremented as follows: new{NFC_RAR[BYTE3, BYTE2, BYTE1]} =
 * {NFC_RAR[BYTE3], NFC_RAR[BYTE2], NFC_RAR[BYTE1]} + {NFC_RAI[INC3, INC2, INC1]}
 */
typedef union _hw_nfc_rai
{
    uint32_t U;
    struct _hw_nfc_rai_bitfields
    {
        uint32_t INC1 : 8;             //!< [7:0] Increment for the first byte of row
                                       //! address
        uint32_t INC2 : 8;             //!< [15:8] Increment for the second byte of row
                                       //! address
        uint32_t INC3 : 8;             //!< [23:16] Increment for the third byte of row
                                       //! address
        uint32_t RESERVED0 : 8;        //!< [31:24]
    } B;
} hw_nfc_rai_t;
#endif

/*!
 * @name Constants and macros for entire NFC_RAI register
 */
//@{
#define HW_NFC_RAI_ADDR          (REGS_NFC_BASE + 0x3F14U)

#ifndef __LANGUAGE_ASM__
#define HW_NFC_RAI               (*(__IO hw_nfc_rai_t *) HW_NFC_RAI_ADDR)
#define HW_NFC_RAI_RD()          (HW_NFC_RAI.U)
#define HW_NFC_RAI_WR(v)         (HW_NFC_RAI.U = (v))
#define HW_NFC_RAI_SET(v)        (HW_NFC_RAI_WR(HW_NFC_RAI_RD() |  (v)))
#define HW_NFC_RAI_CLR(v)        (HW_NFC_RAI_WR(HW_NFC_RAI_RD() & ~(v)))
#define HW_NFC_RAI_TOG(v)        (HW_NFC_RAI_WR(HW_NFC_RAI_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual NFC_RAI bitfields
 */

/*!
 * @name Register NFC_RAI, field INC1[7:0] (RW)
 */
//@{
#define BP_NFC_RAI_INC1      (0U)          //!< Bit position for NFC_RAI_INC1.
#define BM_NFC_RAI_INC1      (0x000000FFU) //!< Bit mask for NFC_RAI_INC1.
#define BS_NFC_RAI_INC1      (8U)          //!< Bit field size in bits for NFC_RAI_INC1.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_RAI_INC1 field.
#define BR_NFC_RAI_INC1      (HW_NFC_RAI.B.INC1)
#endif

//! @brief Format value for bitfield NFC_RAI_INC1.
#define BF_NFC_RAI_INC1(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_RAI_INC1), uint32_t) & BM_NFC_RAI_INC1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INC1 field to a new value.
#define BW_NFC_RAI_INC1(v)   (HW_NFC_RAI_WR((HW_NFC_RAI_RD() & ~BM_NFC_RAI_INC1) | BF_NFC_RAI_INC1(v)))
#endif
//@}

/*!
 * @name Register NFC_RAI, field INC2[15:8] (RW)
 */
//@{
#define BP_NFC_RAI_INC2      (8U)          //!< Bit position for NFC_RAI_INC2.
#define BM_NFC_RAI_INC2      (0x0000FF00U) //!< Bit mask for NFC_RAI_INC2.
#define BS_NFC_RAI_INC2      (8U)          //!< Bit field size in bits for NFC_RAI_INC2.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_RAI_INC2 field.
#define BR_NFC_RAI_INC2      (HW_NFC_RAI.B.INC2)
#endif

//! @brief Format value for bitfield NFC_RAI_INC2.
#define BF_NFC_RAI_INC2(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_RAI_INC2), uint32_t) & BM_NFC_RAI_INC2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INC2 field to a new value.
#define BW_NFC_RAI_INC2(v)   (HW_NFC_RAI_WR((HW_NFC_RAI_RD() & ~BM_NFC_RAI_INC2) | BF_NFC_RAI_INC2(v)))
#endif
//@}

/*!
 * @name Register NFC_RAI, field INC3[23:16] (RW)
 */
//@{
#define BP_NFC_RAI_INC3      (16U)         //!< Bit position for NFC_RAI_INC3.
#define BM_NFC_RAI_INC3      (0x00FF0000U) //!< Bit mask for NFC_RAI_INC3.
#define BS_NFC_RAI_INC3      (8U)          //!< Bit field size in bits for NFC_RAI_INC3.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_RAI_INC3 field.
#define BR_NFC_RAI_INC3      (HW_NFC_RAI.B.INC3)
#endif

//! @brief Format value for bitfield NFC_RAI_INC3.
#define BF_NFC_RAI_INC3(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_RAI_INC3), uint32_t) & BM_NFC_RAI_INC3)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INC3 field to a new value.
#define BW_NFC_RAI_INC3(v)   (HW_NFC_RAI_WR((HW_NFC_RAI_RD() & ~BM_NFC_RAI_INC3) | BF_NFC_RAI_INC3(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_NFC_SR1 - Flash status 1
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_NFC_SR1 - Flash status 1 (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_nfc_sr1
{
    uint32_t U;
    struct _hw_nfc_sr1_bitfields
    {
        uint32_t ID4 : 8;              //!< [7:0] Fourth byte returned by read ID command
        uint32_t ID3 : 8;              //!< [15:8] Third byte returned by read ID command
        uint32_t ID2 : 8;              //!< [23:16] Second byte returned by read ID command
        uint32_t ID1 : 8;              //!< [31:24] First byte returned by read ID command
    } B;
} hw_nfc_sr1_t;
#endif

/*!
 * @name Constants and macros for entire NFC_SR1 register
 */
//@{
#define HW_NFC_SR1_ADDR          (REGS_NFC_BASE + 0x3F18U)

#ifndef __LANGUAGE_ASM__
#define HW_NFC_SR1               (*(__I hw_nfc_sr1_t *) HW_NFC_SR1_ADDR)
#define HW_NFC_SR1_RD()          (HW_NFC_SR1.U)
#endif
//@}

/*
 * Constants & macros for individual NFC_SR1 bitfields
 */

/*!
 * @name Register NFC_SR1, field ID4[7:0] (RO)
 */
//@{
#define BP_NFC_SR1_ID4       (0U)          //!< Bit position for NFC_SR1_ID4.
#define BM_NFC_SR1_ID4       (0x000000FFU) //!< Bit mask for NFC_SR1_ID4.
#define BS_NFC_SR1_ID4       (8U)          //!< Bit field size in bits for NFC_SR1_ID4.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_SR1_ID4 field.
#define BR_NFC_SR1_ID4       (HW_NFC_SR1.B.ID4)
#endif
//@}

/*!
 * @name Register NFC_SR1, field ID3[15:8] (RO)
 */
//@{
#define BP_NFC_SR1_ID3       (8U)          //!< Bit position for NFC_SR1_ID3.
#define BM_NFC_SR1_ID3       (0x0000FF00U) //!< Bit mask for NFC_SR1_ID3.
#define BS_NFC_SR1_ID3       (8U)          //!< Bit field size in bits for NFC_SR1_ID3.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_SR1_ID3 field.
#define BR_NFC_SR1_ID3       (HW_NFC_SR1.B.ID3)
#endif
//@}

/*!
 * @name Register NFC_SR1, field ID2[23:16] (RO)
 */
//@{
#define BP_NFC_SR1_ID2       (16U)         //!< Bit position for NFC_SR1_ID2.
#define BM_NFC_SR1_ID2       (0x00FF0000U) //!< Bit mask for NFC_SR1_ID2.
#define BS_NFC_SR1_ID2       (8U)          //!< Bit field size in bits for NFC_SR1_ID2.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_SR1_ID2 field.
#define BR_NFC_SR1_ID2       (HW_NFC_SR1.B.ID2)
#endif
//@}

/*!
 * @name Register NFC_SR1, field ID1[31:24] (RO)
 */
//@{
#define BP_NFC_SR1_ID1       (24U)         //!< Bit position for NFC_SR1_ID1.
#define BM_NFC_SR1_ID1       (0xFF000000U) //!< Bit mask for NFC_SR1_ID1.
#define BS_NFC_SR1_ID1       (8U)          //!< Bit field size in bits for NFC_SR1_ID1.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_SR1_ID1 field.
#define BR_NFC_SR1_ID1       (HW_NFC_SR1.B.ID1)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_NFC_SR2 - Flash status 2
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_NFC_SR2 - Flash status 2 (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_nfc_sr2
{
    uint32_t U;
    struct _hw_nfc_sr2_bitfields
    {
        uint32_t STATUS1 : 8;          //!< [7:0] Byte returned by read status command
        uint32_t RESERVED0 : 16;       //!< [23:8]
        uint32_t ID5 : 8;              //!< [31:24] Fifth byte returned by read ID command
    } B;
} hw_nfc_sr2_t;
#endif

/*!
 * @name Constants and macros for entire NFC_SR2 register
 */
//@{
#define HW_NFC_SR2_ADDR          (REGS_NFC_BASE + 0x3F1CU)

#ifndef __LANGUAGE_ASM__
#define HW_NFC_SR2               (*(__I hw_nfc_sr2_t *) HW_NFC_SR2_ADDR)
#define HW_NFC_SR2_RD()          (HW_NFC_SR2.U)
#endif
//@}

/*
 * Constants & macros for individual NFC_SR2 bitfields
 */

/*!
 * @name Register NFC_SR2, field STATUS1[7:0] (RO)
 */
//@{
#define BP_NFC_SR2_STATUS1   (0U)          //!< Bit position for NFC_SR2_STATUS1.
#define BM_NFC_SR2_STATUS1   (0x000000FFU) //!< Bit mask for NFC_SR2_STATUS1.
#define BS_NFC_SR2_STATUS1   (8U)          //!< Bit field size in bits for NFC_SR2_STATUS1.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_SR2_STATUS1 field.
#define BR_NFC_SR2_STATUS1   (HW_NFC_SR2.B.STATUS1)
#endif
//@}

/*!
 * @name Register NFC_SR2, field ID5[31:24] (RO)
 */
//@{
#define BP_NFC_SR2_ID5       (24U)         //!< Bit position for NFC_SR2_ID5.
#define BM_NFC_SR2_ID5       (0xFF000000U) //!< Bit mask for NFC_SR2_ID5.
#define BS_NFC_SR2_ID5       (8U)          //!< Bit field size in bits for NFC_SR2_ID5.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_SR2_ID5 field.
#define BR_NFC_SR2_ID5       (HW_NFC_SR2.B.ID5)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_NFC_DMA1 - DMA channel 1 address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_NFC_DMA1 - DMA channel 1 address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_nfc_dma1
{
    uint32_t U;
    struct _hw_nfc_dma1_bitfields
    {
        uint32_t ADDRESS : 32;         //!< [31:0] DMA channel 1 address. DMA channel
                                       //! 1 address, it is 8-byte aligned.
    } B;
} hw_nfc_dma1_t;
#endif

/*!
 * @name Constants and macros for entire NFC_DMA1 register
 */
//@{
#define HW_NFC_DMA1_ADDR         (REGS_NFC_BASE + 0x3F20U)

#ifndef __LANGUAGE_ASM__
#define HW_NFC_DMA1              (*(__IO hw_nfc_dma1_t *) HW_NFC_DMA1_ADDR)
#define HW_NFC_DMA1_RD()         (HW_NFC_DMA1.U)
#define HW_NFC_DMA1_WR(v)        (HW_NFC_DMA1.U = (v))
#define HW_NFC_DMA1_SET(v)       (HW_NFC_DMA1_WR(HW_NFC_DMA1_RD() |  (v)))
#define HW_NFC_DMA1_CLR(v)       (HW_NFC_DMA1_WR(HW_NFC_DMA1_RD() & ~(v)))
#define HW_NFC_DMA1_TOG(v)       (HW_NFC_DMA1_WR(HW_NFC_DMA1_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual NFC_DMA1 bitfields
 */

/*!
 * @name Register NFC_DMA1, field ADDRESS[31:0] (RW)
 */
//@{
#define BP_NFC_DMA1_ADDRESS  (0U)          //!< Bit position for NFC_DMA1_ADDRESS.
#define BM_NFC_DMA1_ADDRESS  (0xFFFFFFFFU) //!< Bit mask for NFC_DMA1_ADDRESS.
#define BS_NFC_DMA1_ADDRESS  (32U)         //!< Bit field size in bits for NFC_DMA1_ADDRESS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_DMA1_ADDRESS field.
#define BR_NFC_DMA1_ADDRESS  (HW_NFC_DMA1.B.ADDRESS)
#endif

//! @brief Format value for bitfield NFC_DMA1_ADDRESS.
#define BF_NFC_DMA1_ADDRESS(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_DMA1_ADDRESS), uint32_t) & BM_NFC_DMA1_ADDRESS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ADDRESS field to a new value.
#define BW_NFC_DMA1_ADDRESS(v) (HW_NFC_DMA1_WR((HW_NFC_DMA1_RD() & ~BM_NFC_DMA1_ADDRESS) | BF_NFC_DMA1_ADDRESS(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_NFC_DMACFG - DMA configuration
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_NFC_DMACFG - DMA configuration (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_nfc_dmacfg
{
    uint32_t U;
    struct _hw_nfc_dmacfg_bitfields
    {
        uint32_t ACT2 : 1;             //!< [0] DMA channel 2 status
        uint32_t ACT1 : 1;             //!< [1] DMA channel 1 status
        uint32_t RESERVED0 : 7;        //!< [8:2]
        uint32_t OFFSET2 : 4;          //!< [12:9] 256-byte offset for DMA channel 2.
                                       //! DMA channel 2 transfer starts at this offset count x 256 bytes. For
                                       //! example, if OFFSET2 = 0x2, DMA channel 2 transfer starts at 0x200.
        uint32_t COUNT2 : 7;           //!< [19:13] Number of bytes to be transferred
                                       //! by DMA channel 2. It should be multiple of 8 bytes.
        uint32_t COUNT1 : 12;          //!< [31:20] Number of bytes to be transferred
                                       //! by DMA channel 1. It should be multiple of 8 bytes.
    } B;
} hw_nfc_dmacfg_t;
#endif

/*!
 * @name Constants and macros for entire NFC_DMACFG register
 */
//@{
#define HW_NFC_DMACFG_ADDR       (REGS_NFC_BASE + 0x3F24U)

#ifndef __LANGUAGE_ASM__
#define HW_NFC_DMACFG            (*(__IO hw_nfc_dmacfg_t *) HW_NFC_DMACFG_ADDR)
#define HW_NFC_DMACFG_RD()       (HW_NFC_DMACFG.U)
#define HW_NFC_DMACFG_WR(v)      (HW_NFC_DMACFG.U = (v))
#define HW_NFC_DMACFG_SET(v)     (HW_NFC_DMACFG_WR(HW_NFC_DMACFG_RD() |  (v)))
#define HW_NFC_DMACFG_CLR(v)     (HW_NFC_DMACFG_WR(HW_NFC_DMACFG_RD() & ~(v)))
#define HW_NFC_DMACFG_TOG(v)     (HW_NFC_DMACFG_WR(HW_NFC_DMACFG_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual NFC_DMACFG bitfields
 */

/*!
 * @name Register NFC_DMACFG, field ACT2[0] (RW)
 *
 * Values:
 * - 0 - Inactive
 * - 1 - Active, and transfers to memory when triggered
 */
//@{
#define BP_NFC_DMACFG_ACT2   (0U)          //!< Bit position for NFC_DMACFG_ACT2.
#define BM_NFC_DMACFG_ACT2   (0x00000001U) //!< Bit mask for NFC_DMACFG_ACT2.
#define BS_NFC_DMACFG_ACT2   (1U)          //!< Bit field size in bits for NFC_DMACFG_ACT2.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_DMACFG_ACT2 field.
#define BR_NFC_DMACFG_ACT2   (BITBAND_ACCESS32(HW_NFC_DMACFG_ADDR, BP_NFC_DMACFG_ACT2))
#endif

//! @brief Format value for bitfield NFC_DMACFG_ACT2.
#define BF_NFC_DMACFG_ACT2(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_DMACFG_ACT2), uint32_t) & BM_NFC_DMACFG_ACT2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACT2 field to a new value.
#define BW_NFC_DMACFG_ACT2(v) (BITBAND_ACCESS32(HW_NFC_DMACFG_ADDR, BP_NFC_DMACFG_ACT2) = (v))
#endif
//@}

/*!
 * @name Register NFC_DMACFG, field ACT1[1] (RW)
 *
 * Values:
 * - 0 - Inactive
 * - 1 - Active, and transfers to memory when triggered
 */
//@{
#define BP_NFC_DMACFG_ACT1   (1U)          //!< Bit position for NFC_DMACFG_ACT1.
#define BM_NFC_DMACFG_ACT1   (0x00000002U) //!< Bit mask for NFC_DMACFG_ACT1.
#define BS_NFC_DMACFG_ACT1   (1U)          //!< Bit field size in bits for NFC_DMACFG_ACT1.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_DMACFG_ACT1 field.
#define BR_NFC_DMACFG_ACT1   (BITBAND_ACCESS32(HW_NFC_DMACFG_ADDR, BP_NFC_DMACFG_ACT1))
#endif

//! @brief Format value for bitfield NFC_DMACFG_ACT1.
#define BF_NFC_DMACFG_ACT1(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_DMACFG_ACT1), uint32_t) & BM_NFC_DMACFG_ACT1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACT1 field to a new value.
#define BW_NFC_DMACFG_ACT1(v) (BITBAND_ACCESS32(HW_NFC_DMACFG_ADDR, BP_NFC_DMACFG_ACT1) = (v))
#endif
//@}

/*!
 * @name Register NFC_DMACFG, field OFFSET2[12:9] (RW)
 */
//@{
#define BP_NFC_DMACFG_OFFSET2 (9U)         //!< Bit position for NFC_DMACFG_OFFSET2.
#define BM_NFC_DMACFG_OFFSET2 (0x00001E00U) //!< Bit mask for NFC_DMACFG_OFFSET2.
#define BS_NFC_DMACFG_OFFSET2 (4U)         //!< Bit field size in bits for NFC_DMACFG_OFFSET2.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_DMACFG_OFFSET2 field.
#define BR_NFC_DMACFG_OFFSET2 (HW_NFC_DMACFG.B.OFFSET2)
#endif

//! @brief Format value for bitfield NFC_DMACFG_OFFSET2.
#define BF_NFC_DMACFG_OFFSET2(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_DMACFG_OFFSET2), uint32_t) & BM_NFC_DMACFG_OFFSET2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the OFFSET2 field to a new value.
#define BW_NFC_DMACFG_OFFSET2(v) (HW_NFC_DMACFG_WR((HW_NFC_DMACFG_RD() & ~BM_NFC_DMACFG_OFFSET2) | BF_NFC_DMACFG_OFFSET2(v)))
#endif
//@}

/*!
 * @name Register NFC_DMACFG, field COUNT2[19:13] (RW)
 */
//@{
#define BP_NFC_DMACFG_COUNT2 (13U)         //!< Bit position for NFC_DMACFG_COUNT2.
#define BM_NFC_DMACFG_COUNT2 (0x000FE000U) //!< Bit mask for NFC_DMACFG_COUNT2.
#define BS_NFC_DMACFG_COUNT2 (7U)          //!< Bit field size in bits for NFC_DMACFG_COUNT2.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_DMACFG_COUNT2 field.
#define BR_NFC_DMACFG_COUNT2 (HW_NFC_DMACFG.B.COUNT2)
#endif

//! @brief Format value for bitfield NFC_DMACFG_COUNT2.
#define BF_NFC_DMACFG_COUNT2(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_DMACFG_COUNT2), uint32_t) & BM_NFC_DMACFG_COUNT2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the COUNT2 field to a new value.
#define BW_NFC_DMACFG_COUNT2(v) (HW_NFC_DMACFG_WR((HW_NFC_DMACFG_RD() & ~BM_NFC_DMACFG_COUNT2) | BF_NFC_DMACFG_COUNT2(v)))
#endif
//@}

/*!
 * @name Register NFC_DMACFG, field COUNT1[31:20] (RW)
 */
//@{
#define BP_NFC_DMACFG_COUNT1 (20U)         //!< Bit position for NFC_DMACFG_COUNT1.
#define BM_NFC_DMACFG_COUNT1 (0xFFF00000U) //!< Bit mask for NFC_DMACFG_COUNT1.
#define BS_NFC_DMACFG_COUNT1 (12U)         //!< Bit field size in bits for NFC_DMACFG_COUNT1.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_DMACFG_COUNT1 field.
#define BR_NFC_DMACFG_COUNT1 (HW_NFC_DMACFG.B.COUNT1)
#endif

//! @brief Format value for bitfield NFC_DMACFG_COUNT1.
#define BF_NFC_DMACFG_COUNT1(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_DMACFG_COUNT1), uint32_t) & BM_NFC_DMACFG_COUNT1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the COUNT1 field to a new value.
#define BW_NFC_DMACFG_COUNT1(v) (HW_NFC_DMACFG_WR((HW_NFC_DMACFG_RD() & ~BM_NFC_DMACFG_COUNT1) | BF_NFC_DMACFG_COUNT1(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_NFC_SWAP - Cach swap
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_NFC_SWAP - Cach swap (RW)
 *
 * Reset value: 0x0FFE0FFEU
 *
 * When DMA transfers data to/from the NFC cache (NFC SRAM buffer), or when the
 * CPU reads or writes data to/from the NFC cache via the internal bus, all
 * accesses that go to NFC_SWAP[ADDR1] are directed to NFC_SWAP[ADDR2]. Likewise, all
 * accesses that go to NFC_SWAP[ADDR2] are directed to NFC_SWAP[ADDR1]. The
 * feature allows the bad block marker in the first position of the spare area of a
 * page. Because of the way the flash controller interleaves data and ECC bytes on
 * flash devices with page sizes larger than 2 KB, the position of the bad block
 * marker is shifted, and does not appear in the first position of the spare area
 * of the page. The cache swap feature allows consistent swapping of the actual
 * bad block line with the expected bad block line, and causes the operating
 * system to get the bad block marker in the position where it is expected.
 */
typedef union _hw_nfc_swap
{
    uint32_t U;
    struct _hw_nfc_swap_bitfields
    {
        uint32_t RESERVED0 : 1;        //!< [0]
        uint32_t ADDR2 : 11;           //!< [11:1] Upper swap address
        uint32_t RESERVED1 : 5;        //!< [16:12]
        uint32_t ADDR1 : 11;           //!< [27:17] Lower swap address
        uint32_t RESERVED2 : 4;        //!< [31:28]
    } B;
} hw_nfc_swap_t;
#endif

/*!
 * @name Constants and macros for entire NFC_SWAP register
 */
//@{
#define HW_NFC_SWAP_ADDR         (REGS_NFC_BASE + 0x3F28U)

#ifndef __LANGUAGE_ASM__
#define HW_NFC_SWAP              (*(__IO hw_nfc_swap_t *) HW_NFC_SWAP_ADDR)
#define HW_NFC_SWAP_RD()         (HW_NFC_SWAP.U)
#define HW_NFC_SWAP_WR(v)        (HW_NFC_SWAP.U = (v))
#define HW_NFC_SWAP_SET(v)       (HW_NFC_SWAP_WR(HW_NFC_SWAP_RD() |  (v)))
#define HW_NFC_SWAP_CLR(v)       (HW_NFC_SWAP_WR(HW_NFC_SWAP_RD() & ~(v)))
#define HW_NFC_SWAP_TOG(v)       (HW_NFC_SWAP_WR(HW_NFC_SWAP_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual NFC_SWAP bitfields
 */

/*!
 * @name Register NFC_SWAP, field ADDR2[11:1] (RW)
 */
//@{
#define BP_NFC_SWAP_ADDR2    (1U)          //!< Bit position for NFC_SWAP_ADDR2.
#define BM_NFC_SWAP_ADDR2    (0x00000FFEU) //!< Bit mask for NFC_SWAP_ADDR2.
#define BS_NFC_SWAP_ADDR2    (11U)         //!< Bit field size in bits for NFC_SWAP_ADDR2.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_SWAP_ADDR2 field.
#define BR_NFC_SWAP_ADDR2    (HW_NFC_SWAP.B.ADDR2)
#endif

//! @brief Format value for bitfield NFC_SWAP_ADDR2.
#define BF_NFC_SWAP_ADDR2(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_SWAP_ADDR2), uint32_t) & BM_NFC_SWAP_ADDR2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ADDR2 field to a new value.
#define BW_NFC_SWAP_ADDR2(v) (HW_NFC_SWAP_WR((HW_NFC_SWAP_RD() & ~BM_NFC_SWAP_ADDR2) | BF_NFC_SWAP_ADDR2(v)))
#endif
//@}

/*!
 * @name Register NFC_SWAP, field ADDR1[27:17] (RW)
 */
//@{
#define BP_NFC_SWAP_ADDR1    (17U)         //!< Bit position for NFC_SWAP_ADDR1.
#define BM_NFC_SWAP_ADDR1    (0x0FFE0000U) //!< Bit mask for NFC_SWAP_ADDR1.
#define BS_NFC_SWAP_ADDR1    (11U)         //!< Bit field size in bits for NFC_SWAP_ADDR1.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_SWAP_ADDR1 field.
#define BR_NFC_SWAP_ADDR1    (HW_NFC_SWAP.B.ADDR1)
#endif

//! @brief Format value for bitfield NFC_SWAP_ADDR1.
#define BF_NFC_SWAP_ADDR1(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_SWAP_ADDR1), uint32_t) & BM_NFC_SWAP_ADDR1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ADDR1 field to a new value.
#define BW_NFC_SWAP_ADDR1(v) (HW_NFC_SWAP_WR((HW_NFC_SWAP_RD() & ~BM_NFC_SWAP_ADDR1) | BF_NFC_SWAP_ADDR1(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_NFC_SECSZ - Sector size
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_NFC_SECSZ - Sector size (RW)
 *
 * Reset value: 0x00000420U
 */
typedef union _hw_nfc_secsz
{
    uint32_t U;
    struct _hw_nfc_secsz_bitfields
    {
        uint32_t SIZE : 13;            //!< [12:0] Size in bytes of one elementary
                                       //! transfer unit
        uint32_t RESERVED0 : 19;       //!< [31:13]
    } B;
} hw_nfc_secsz_t;
#endif

/*!
 * @name Constants and macros for entire NFC_SECSZ register
 */
//@{
#define HW_NFC_SECSZ_ADDR        (REGS_NFC_BASE + 0x3F2CU)

#ifndef __LANGUAGE_ASM__
#define HW_NFC_SECSZ             (*(__IO hw_nfc_secsz_t *) HW_NFC_SECSZ_ADDR)
#define HW_NFC_SECSZ_RD()        (HW_NFC_SECSZ.U)
#define HW_NFC_SECSZ_WR(v)       (HW_NFC_SECSZ.U = (v))
#define HW_NFC_SECSZ_SET(v)      (HW_NFC_SECSZ_WR(HW_NFC_SECSZ_RD() |  (v)))
#define HW_NFC_SECSZ_CLR(v)      (HW_NFC_SECSZ_WR(HW_NFC_SECSZ_RD() & ~(v)))
#define HW_NFC_SECSZ_TOG(v)      (HW_NFC_SECSZ_WR(HW_NFC_SECSZ_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual NFC_SECSZ bitfields
 */

/*!
 * @name Register NFC_SECSZ, field SIZE[12:0] (RW)
 *
 * For devices with pages of 2KB and smaller, this is the physical size of the
 * page in bytes (data bytes + ECC bytes) transferred in one page. When pages are
 * larger than 2KB, they must be split in multiple virtual pages. In this case,
 * the sector size is the size of the virtual page. The virtual page size is the
 * physical size divided by the splitting factor, NFC_CFG[PAGECNT]. If only a part
 * of a page to be programmed or read, SIZE can be set to the number of affected
 * bytes, not the page size. Then, ECC and DMA (data bytes) are all performed on
 * the number of bytes, indicated by SIZE. For 16-bit data width flash devices,
 * only odd SIZE is supported. If SIZE is even number, the real implemented size
 * is SIZE - 1. So, write size + 1 to this field. For example, if SIZE = 1, no
 * data is written or read. When programming NAND memory using the ECC feature,
 * ensure that SIZE is equal to the default value (data + ECC bytes).
 */
//@{
#define BP_NFC_SECSZ_SIZE    (0U)          //!< Bit position for NFC_SECSZ_SIZE.
#define BM_NFC_SECSZ_SIZE    (0x00001FFFU) //!< Bit mask for NFC_SECSZ_SIZE.
#define BS_NFC_SECSZ_SIZE    (13U)         //!< Bit field size in bits for NFC_SECSZ_SIZE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_SECSZ_SIZE field.
#define BR_NFC_SECSZ_SIZE    (HW_NFC_SECSZ.B.SIZE)
#endif

//! @brief Format value for bitfield NFC_SECSZ_SIZE.
#define BF_NFC_SECSZ_SIZE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_SECSZ_SIZE), uint32_t) & BM_NFC_SECSZ_SIZE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SIZE field to a new value.
#define BW_NFC_SECSZ_SIZE(v) (HW_NFC_SECSZ_WR((HW_NFC_SECSZ_RD() & ~BM_NFC_SECSZ_SIZE) | BF_NFC_SECSZ_SIZE(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_NFC_CFG - Flash configuration
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_NFC_CFG - Flash configuration (RW)
 *
 * Reset value: 0x000EA631U
 */
typedef union _hw_nfc_cfg
{
    uint32_t U;
    struct _hw_nfc_cfg_bitfields
    {
        uint32_t PAGECNT : 4;          //!< [3:0] Number of virtual pages (in one
                                       //! physical flash page) to be programmed or read, etc.
        uint32_t AIBN : 1;             //!< [4]
        uint32_t AIAD : 1;             //!< [5]
        uint32_t RESERVED0 : 1;        //!< [6]
        uint32_t BITWIDTH : 1;         //!< [7]
        uint32_t TIMEOUT : 5;          //!< [12:8]
        uint32_t IDCNT : 3;            //!< [15:13] Number of bytes that are read for
                                       //! the read id command.
        uint32_t FAST : 1;             //!< [16] See the "Fast Flash Configuration for
                                       //! EDO" section for more details.
        uint32_t ECCMODE : 3;          //!< [19:17]
        uint32_t DMAREQ : 1;           //!< [20]
        uint32_t ECCSRAM : 1;          //!< [21]
        uint32_t ECCAD : 9;            //!< [30:22] Byte address in SRAM where ECC
                                       //! status is written.
        uint32_t STOPWERR : 1;         //!< [31]
    } B;
} hw_nfc_cfg_t;
#endif

/*!
 * @name Constants and macros for entire NFC_CFG register
 */
//@{
#define HW_NFC_CFG_ADDR          (REGS_NFC_BASE + 0x3F30U)

#ifndef __LANGUAGE_ASM__
#define HW_NFC_CFG               (*(__IO hw_nfc_cfg_t *) HW_NFC_CFG_ADDR)
#define HW_NFC_CFG_RD()          (HW_NFC_CFG.U)
#define HW_NFC_CFG_WR(v)         (HW_NFC_CFG.U = (v))
#define HW_NFC_CFG_SET(v)        (HW_NFC_CFG_WR(HW_NFC_CFG_RD() |  (v)))
#define HW_NFC_CFG_CLR(v)        (HW_NFC_CFG_WR(HW_NFC_CFG_RD() & ~(v)))
#define HW_NFC_CFG_TOG(v)        (HW_NFC_CFG_WR(HW_NFC_CFG_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual NFC_CFG bitfields
 */

/*!
 * @name Register NFC_CFG, field PAGECNT[3:0] (RW)
 */
//@{
#define BP_NFC_CFG_PAGECNT   (0U)          //!< Bit position for NFC_CFG_PAGECNT.
#define BM_NFC_CFG_PAGECNT   (0x0000000FU) //!< Bit mask for NFC_CFG_PAGECNT.
#define BS_NFC_CFG_PAGECNT   (4U)          //!< Bit field size in bits for NFC_CFG_PAGECNT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_CFG_PAGECNT field.
#define BR_NFC_CFG_PAGECNT   (HW_NFC_CFG.B.PAGECNT)
#endif

//! @brief Format value for bitfield NFC_CFG_PAGECNT.
#define BF_NFC_CFG_PAGECNT(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_CFG_PAGECNT), uint32_t) & BM_NFC_CFG_PAGECNT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PAGECNT field to a new value.
#define BW_NFC_CFG_PAGECNT(v) (HW_NFC_CFG_WR((HW_NFC_CFG_RD() & ~BM_NFC_CFG_PAGECNT) | BF_NFC_CFG_PAGECNT(v)))
#endif
//@}

/*!
 * @name Register NFC_CFG, field AIBN[4] (RW)
 *
 * Values:
 * - 0 - Do not auto-increment buffer number
 * - 1 - Auto-increment buffer number
 */
//@{
#define BP_NFC_CFG_AIBN      (4U)          //!< Bit position for NFC_CFG_AIBN.
#define BM_NFC_CFG_AIBN      (0x00000010U) //!< Bit mask for NFC_CFG_AIBN.
#define BS_NFC_CFG_AIBN      (1U)          //!< Bit field size in bits for NFC_CFG_AIBN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_CFG_AIBN field.
#define BR_NFC_CFG_AIBN      (BITBAND_ACCESS32(HW_NFC_CFG_ADDR, BP_NFC_CFG_AIBN))
#endif

//! @brief Format value for bitfield NFC_CFG_AIBN.
#define BF_NFC_CFG_AIBN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_CFG_AIBN), uint32_t) & BM_NFC_CFG_AIBN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the AIBN field to a new value.
#define BW_NFC_CFG_AIBN(v)   (BITBAND_ACCESS32(HW_NFC_CFG_ADDR, BP_NFC_CFG_AIBN) = (v))
#endif
//@}

/*!
 * @name Register NFC_CFG, field AIAD[5] (RW)
 *
 * Values:
 * - 0 - Do not auto-increment flash row address
 * - 1 - Auto-increment flash row address
 */
//@{
#define BP_NFC_CFG_AIAD      (5U)          //!< Bit position for NFC_CFG_AIAD.
#define BM_NFC_CFG_AIAD      (0x00000020U) //!< Bit mask for NFC_CFG_AIAD.
#define BS_NFC_CFG_AIAD      (1U)          //!< Bit field size in bits for NFC_CFG_AIAD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_CFG_AIAD field.
#define BR_NFC_CFG_AIAD      (BITBAND_ACCESS32(HW_NFC_CFG_ADDR, BP_NFC_CFG_AIAD))
#endif

//! @brief Format value for bitfield NFC_CFG_AIAD.
#define BF_NFC_CFG_AIAD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_CFG_AIAD), uint32_t) & BM_NFC_CFG_AIAD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the AIAD field to a new value.
#define BW_NFC_CFG_AIAD(v)   (BITBAND_ACCESS32(HW_NFC_CFG_ADDR, BP_NFC_CFG_AIAD) = (v))
#endif
//@}

/*!
 * @name Register NFC_CFG, field BITWIDTH[7] (RW)
 *
 * Values:
 * - 0 - 8-bit wide flash mode
 * - 1 - 16-bit wide flash mode
 */
//@{
#define BP_NFC_CFG_BITWIDTH  (7U)          //!< Bit position for NFC_CFG_BITWIDTH.
#define BM_NFC_CFG_BITWIDTH  (0x00000080U) //!< Bit mask for NFC_CFG_BITWIDTH.
#define BS_NFC_CFG_BITWIDTH  (1U)          //!< Bit field size in bits for NFC_CFG_BITWIDTH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_CFG_BITWIDTH field.
#define BR_NFC_CFG_BITWIDTH  (BITBAND_ACCESS32(HW_NFC_CFG_ADDR, BP_NFC_CFG_BITWIDTH))
#endif

//! @brief Format value for bitfield NFC_CFG_BITWIDTH.
#define BF_NFC_CFG_BITWIDTH(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_CFG_BITWIDTH), uint32_t) & BM_NFC_CFG_BITWIDTH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BITWIDTH field to a new value.
#define BW_NFC_CFG_BITWIDTH(v) (BITBAND_ACCESS32(HW_NFC_CFG_ADDR, BP_NFC_CFG_BITWIDTH) = (v))
#endif
//@}

/*!
 * @name Register NFC_CFG, field TIMEOUT[12:8] (RW)
 *
 * The number of flash_clk cycles from NFC_WE high to either: NAND flash busy (t
 * WB ), or NFC_RE low (t WHR ) After the last command is issued to flash,
 * before sampling NFC_R/ B , the NFC must wait t WB clocks. After t WB clocks: if
 * NFC_R/ B is sampled as high, the NFC considers the command to be a timeout, and
 * the flash memory is idle. The NFC can issue new commands to the flash memory.
 * if NFC_R/ B is sampled as low, the NAND flash memory is busy. When reading the
 * status or ID from the NAND flash memory, after the last command is issued to
 * flash, the NFC must wait for t WHR cycles. The NFC then negates NFC_RE to low
 * to read the valid status or ID. t WB exists in page program/read, block erase,
 * etc. Refer to the NAND flash datasheet for details of t WB and t WHR .
 */
//@{
#define BP_NFC_CFG_TIMEOUT   (8U)          //!< Bit position for NFC_CFG_TIMEOUT.
#define BM_NFC_CFG_TIMEOUT   (0x00001F00U) //!< Bit mask for NFC_CFG_TIMEOUT.
#define BS_NFC_CFG_TIMEOUT   (5U)          //!< Bit field size in bits for NFC_CFG_TIMEOUT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_CFG_TIMEOUT field.
#define BR_NFC_CFG_TIMEOUT   (HW_NFC_CFG.B.TIMEOUT)
#endif

//! @brief Format value for bitfield NFC_CFG_TIMEOUT.
#define BF_NFC_CFG_TIMEOUT(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_CFG_TIMEOUT), uint32_t) & BM_NFC_CFG_TIMEOUT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TIMEOUT field to a new value.
#define BW_NFC_CFG_TIMEOUT(v) (HW_NFC_CFG_WR((HW_NFC_CFG_RD() & ~BM_NFC_CFG_TIMEOUT) | BF_NFC_CFG_TIMEOUT(v)))
#endif
//@}

/*!
 * @name Register NFC_CFG, field IDCNT[15:13] (RW)
 */
//@{
#define BP_NFC_CFG_IDCNT     (13U)         //!< Bit position for NFC_CFG_IDCNT.
#define BM_NFC_CFG_IDCNT     (0x0000E000U) //!< Bit mask for NFC_CFG_IDCNT.
#define BS_NFC_CFG_IDCNT     (3U)          //!< Bit field size in bits for NFC_CFG_IDCNT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_CFG_IDCNT field.
#define BR_NFC_CFG_IDCNT     (HW_NFC_CFG.B.IDCNT)
#endif

//! @brief Format value for bitfield NFC_CFG_IDCNT.
#define BF_NFC_CFG_IDCNT(v)  (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_CFG_IDCNT), uint32_t) & BM_NFC_CFG_IDCNT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the IDCNT field to a new value.
#define BW_NFC_CFG_IDCNT(v)  (HW_NFC_CFG_WR((HW_NFC_CFG_RD() & ~BM_NFC_CFG_IDCNT) | BF_NFC_CFG_IDCNT(v)))
#endif
//@}

/*!
 * @name Register NFC_CFG, field FAST[16] (RW)
 *
 * Values:
 * - 0 - Slow flash timing. Clock in read data on rising edge of read strobe
 * - 1 - Fast flash timing. Clock in read data a half clock later than rising
 *     edge of read strobe
 */
//@{
#define BP_NFC_CFG_FAST      (16U)         //!< Bit position for NFC_CFG_FAST.
#define BM_NFC_CFG_FAST      (0x00010000U) //!< Bit mask for NFC_CFG_FAST.
#define BS_NFC_CFG_FAST      (1U)          //!< Bit field size in bits for NFC_CFG_FAST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_CFG_FAST field.
#define BR_NFC_CFG_FAST      (BITBAND_ACCESS32(HW_NFC_CFG_ADDR, BP_NFC_CFG_FAST))
#endif

//! @brief Format value for bitfield NFC_CFG_FAST.
#define BF_NFC_CFG_FAST(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_CFG_FAST), uint32_t) & BM_NFC_CFG_FAST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the FAST field to a new value.
#define BW_NFC_CFG_FAST(v)   (BITBAND_ACCESS32(HW_NFC_CFG_ADDR, BP_NFC_CFG_FAST) = (v))
#endif
//@}

/*!
 * @name Register NFC_CFG, field ECCMODE[19:17] (RW)
 *
 * Values:
 * - 000 - No correction, ECC bypass
 * - 001 - 4-error correction (8 ECC bytes)
 * - 010 - 6-error correction (12 ECC bytes)
 * - 011 - 8-error correction (15 ECC bytes)
 * - 100 - 12-error correction (23 ECC bytes)
 * - 101 - 16-error correction (30 ECC bytes)
 * - 110 - 24-error correction (45 ECC bytes)
 * - 111 - 32-error correction (60 ECC bytes)
 */
//@{
#define BP_NFC_CFG_ECCMODE   (17U)         //!< Bit position for NFC_CFG_ECCMODE.
#define BM_NFC_CFG_ECCMODE   (0x000E0000U) //!< Bit mask for NFC_CFG_ECCMODE.
#define BS_NFC_CFG_ECCMODE   (3U)          //!< Bit field size in bits for NFC_CFG_ECCMODE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_CFG_ECCMODE field.
#define BR_NFC_CFG_ECCMODE   (HW_NFC_CFG.B.ECCMODE)
#endif

//! @brief Format value for bitfield NFC_CFG_ECCMODE.
#define BF_NFC_CFG_ECCMODE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_CFG_ECCMODE), uint32_t) & BM_NFC_CFG_ECCMODE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECCMODE field to a new value.
#define BW_NFC_CFG_ECCMODE(v) (HW_NFC_CFG_WR((HW_NFC_CFG_RD() & ~BM_NFC_CFG_ECCMODE) | BF_NFC_CFG_ECCMODE(v)))
#endif
//@}

/*!
 * @name Register NFC_CFG, field DMAREQ[20] (RW)
 *
 * Values:
 * - 0 - Do not transfer sector after ECC done
 * - 1 - After ECC done, transfer sector using DMA
 */
//@{
#define BP_NFC_CFG_DMAREQ    (20U)         //!< Bit position for NFC_CFG_DMAREQ.
#define BM_NFC_CFG_DMAREQ    (0x00100000U) //!< Bit mask for NFC_CFG_DMAREQ.
#define BS_NFC_CFG_DMAREQ    (1U)          //!< Bit field size in bits for NFC_CFG_DMAREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_CFG_DMAREQ field.
#define BR_NFC_CFG_DMAREQ    (BITBAND_ACCESS32(HW_NFC_CFG_ADDR, BP_NFC_CFG_DMAREQ))
#endif

//! @brief Format value for bitfield NFC_CFG_DMAREQ.
#define BF_NFC_CFG_DMAREQ(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_CFG_DMAREQ), uint32_t) & BM_NFC_CFG_DMAREQ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMAREQ field to a new value.
#define BW_NFC_CFG_DMAREQ(v) (BITBAND_ACCESS32(HW_NFC_CFG_ADDR, BP_NFC_CFG_DMAREQ) = (v))
#endif
//@}

/*!
 * @name Register NFC_CFG, field ECCSRAM[21] (RW)
 *
 * Values:
 * - 0 - Do not write ECC status to SRAM
 * - 1 - Write ECC status to SRAM
 */
//@{
#define BP_NFC_CFG_ECCSRAM   (21U)         //!< Bit position for NFC_CFG_ECCSRAM.
#define BM_NFC_CFG_ECCSRAM   (0x00200000U) //!< Bit mask for NFC_CFG_ECCSRAM.
#define BS_NFC_CFG_ECCSRAM   (1U)          //!< Bit field size in bits for NFC_CFG_ECCSRAM.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_CFG_ECCSRAM field.
#define BR_NFC_CFG_ECCSRAM   (BITBAND_ACCESS32(HW_NFC_CFG_ADDR, BP_NFC_CFG_ECCSRAM))
#endif

//! @brief Format value for bitfield NFC_CFG_ECCSRAM.
#define BF_NFC_CFG_ECCSRAM(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_CFG_ECCSRAM), uint32_t) & BM_NFC_CFG_ECCSRAM)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECCSRAM field to a new value.
#define BW_NFC_CFG_ECCSRAM(v) (BITBAND_ACCESS32(HW_NFC_CFG_ADDR, BP_NFC_CFG_ECCSRAM) = (v))
#endif
//@}

/*!
 * @name Register NFC_CFG, field ECCAD[30:22] (RW)
 */
//@{
#define BP_NFC_CFG_ECCAD     (22U)         //!< Bit position for NFC_CFG_ECCAD.
#define BM_NFC_CFG_ECCAD     (0x7FC00000U) //!< Bit mask for NFC_CFG_ECCAD.
#define BS_NFC_CFG_ECCAD     (9U)          //!< Bit field size in bits for NFC_CFG_ECCAD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_CFG_ECCAD field.
#define BR_NFC_CFG_ECCAD     (HW_NFC_CFG.B.ECCAD)
#endif

//! @brief Format value for bitfield NFC_CFG_ECCAD.
#define BF_NFC_CFG_ECCAD(v)  (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_CFG_ECCAD), uint32_t) & BM_NFC_CFG_ECCAD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ECCAD field to a new value.
#define BW_NFC_CFG_ECCAD(v)  (HW_NFC_CFG_WR((HW_NFC_CFG_RD() & ~BM_NFC_CFG_ECCAD) | BF_NFC_CFG_ECCAD(v)))
#endif
//@}

/*!
 * @name Register NFC_CFG, field STOPWERR[31] (RW)
 *
 * Values:
 * - 0 - No stop on write error
 * - 1 - Auto-sequencer stops on a write error
 */
//@{
#define BP_NFC_CFG_STOPWERR  (31U)         //!< Bit position for NFC_CFG_STOPWERR.
#define BM_NFC_CFG_STOPWERR  (0x80000000U) //!< Bit mask for NFC_CFG_STOPWERR.
#define BS_NFC_CFG_STOPWERR  (1U)          //!< Bit field size in bits for NFC_CFG_STOPWERR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_CFG_STOPWERR field.
#define BR_NFC_CFG_STOPWERR  (BITBAND_ACCESS32(HW_NFC_CFG_ADDR, BP_NFC_CFG_STOPWERR))
#endif

//! @brief Format value for bitfield NFC_CFG_STOPWERR.
#define BF_NFC_CFG_STOPWERR(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_CFG_STOPWERR), uint32_t) & BM_NFC_CFG_STOPWERR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the STOPWERR field to a new value.
#define BW_NFC_CFG_STOPWERR(v) (BITBAND_ACCESS32(HW_NFC_CFG_ADDR, BP_NFC_CFG_STOPWERR) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_NFC_DMA2 - DMA channel 2 address
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_NFC_DMA2 - DMA channel 2 address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_nfc_dma2
{
    uint32_t U;
    struct _hw_nfc_dma2_bitfields
    {
        uint32_t ADDRESS : 32;         //!< [31:0] DMA channel 2 address. DMA channel
                                       //! 2 address, it is 8-byte aligned.
    } B;
} hw_nfc_dma2_t;
#endif

/*!
 * @name Constants and macros for entire NFC_DMA2 register
 */
//@{
#define HW_NFC_DMA2_ADDR         (REGS_NFC_BASE + 0x3F34U)

#ifndef __LANGUAGE_ASM__
#define HW_NFC_DMA2              (*(__IO hw_nfc_dma2_t *) HW_NFC_DMA2_ADDR)
#define HW_NFC_DMA2_RD()         (HW_NFC_DMA2.U)
#define HW_NFC_DMA2_WR(v)        (HW_NFC_DMA2.U = (v))
#define HW_NFC_DMA2_SET(v)       (HW_NFC_DMA2_WR(HW_NFC_DMA2_RD() |  (v)))
#define HW_NFC_DMA2_CLR(v)       (HW_NFC_DMA2_WR(HW_NFC_DMA2_RD() & ~(v)))
#define HW_NFC_DMA2_TOG(v)       (HW_NFC_DMA2_WR(HW_NFC_DMA2_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual NFC_DMA2 bitfields
 */

/*!
 * @name Register NFC_DMA2, field ADDRESS[31:0] (RW)
 */
//@{
#define BP_NFC_DMA2_ADDRESS  (0U)          //!< Bit position for NFC_DMA2_ADDRESS.
#define BM_NFC_DMA2_ADDRESS  (0xFFFFFFFFU) //!< Bit mask for NFC_DMA2_ADDRESS.
#define BS_NFC_DMA2_ADDRESS  (32U)         //!< Bit field size in bits for NFC_DMA2_ADDRESS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_DMA2_ADDRESS field.
#define BR_NFC_DMA2_ADDRESS  (HW_NFC_DMA2.B.ADDRESS)
#endif

//! @brief Format value for bitfield NFC_DMA2_ADDRESS.
#define BF_NFC_DMA2_ADDRESS(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_DMA2_ADDRESS), uint32_t) & BM_NFC_DMA2_ADDRESS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ADDRESS field to a new value.
#define BW_NFC_DMA2_ADDRESS(v) (HW_NFC_DMA2_WR((HW_NFC_DMA2_RD() & ~BM_NFC_DMA2_ADDRESS) | BF_NFC_DMA2_ADDRESS(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_NFC_ISR - Interrupt status
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_NFC_ISR - Interrupt status (RW)
 *
 * Reset value: 0x60000000U
 */
typedef union _hw_nfc_isr
{
    uint32_t U;
    struct _hw_nfc_isr_bitfields
    {
        uint32_t DMABN : 2;            //!< [1:0] DMA buffer number
        uint32_t ECCBN : 2;            //!< [3:2] ECC buffer number
        uint32_t RESBN : 2;            //!< [5:4] Residue buffer number
        uint32_t RESERVED0 : 11;       //!< [16:6]
        uint32_t IDLECLR : 1;          //!< [17]
        uint32_t DONECLR : 1;          //!< [18]
        uint32_t WERRCLR : 1;          //!< [19]
        uint32_t IDLEEN : 1;           //!< [20]
        uint32_t DONEEN : 1;           //!< [21]
        uint32_t WERREN : 1;           //!< [22]
        uint32_t DMABUSY : 1;          //!< [23] DMA engine busy
        uint32_t ECCBUSY : 1;          //!< [24] ECC engine busy
        uint32_t RESBUSY : 1;          //!< [25] Residue engine busy
        uint32_t CMDBUSY : 1;          //!< [26] Command busy
        uint32_t WERRNS : 1;           //!< [27] Write error status
        uint32_t RESERVED1 : 1;        //!< [28]
        uint32_t IDLE : 1;             //!< [29] Command idle interrupt
        uint32_t DONE : 1;             //!< [30] Done interrupt
        uint32_t WERR : 1;             //!< [31] Write error interrupt
    } B;
} hw_nfc_isr_t;
#endif

/*!
 * @name Constants and macros for entire NFC_ISR register
 */
//@{
#define HW_NFC_ISR_ADDR          (REGS_NFC_BASE + 0x3F38U)

#ifndef __LANGUAGE_ASM__
#define HW_NFC_ISR               (*(__IO hw_nfc_isr_t *) HW_NFC_ISR_ADDR)
#define HW_NFC_ISR_RD()          (HW_NFC_ISR.U)
#define HW_NFC_ISR_WR(v)         (HW_NFC_ISR.U = (v))
#define HW_NFC_ISR_SET(v)        (HW_NFC_ISR_WR(HW_NFC_ISR_RD() |  (v)))
#define HW_NFC_ISR_CLR(v)        (HW_NFC_ISR_WR(HW_NFC_ISR_RD() & ~(v)))
#define HW_NFC_ISR_TOG(v)        (HW_NFC_ISR_WR(HW_NFC_ISR_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual NFC_ISR bitfields
 */

/*!
 * @name Register NFC_ISR, field DMABN[1:0] (RO)
 *
 * Buffer number corresponding with the current DMA task.
 */
//@{
#define BP_NFC_ISR_DMABN     (0U)          //!< Bit position for NFC_ISR_DMABN.
#define BM_NFC_ISR_DMABN     (0x00000003U) //!< Bit mask for NFC_ISR_DMABN.
#define BS_NFC_ISR_DMABN     (2U)          //!< Bit field size in bits for NFC_ISR_DMABN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_ISR_DMABN field.
#define BR_NFC_ISR_DMABN     (HW_NFC_ISR.B.DMABN)
#endif
//@}

/*!
 * @name Register NFC_ISR, field ECCBN[3:2] (RO)
 *
 * Buffer number corresponding with the current ECC task.
 */
//@{
#define BP_NFC_ISR_ECCBN     (2U)          //!< Bit position for NFC_ISR_ECCBN.
#define BM_NFC_ISR_ECCBN     (0x0000000CU) //!< Bit mask for NFC_ISR_ECCBN.
#define BS_NFC_ISR_ECCBN     (2U)          //!< Bit field size in bits for NFC_ISR_ECCBN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_ISR_ECCBN field.
#define BR_NFC_ISR_ECCBN     (HW_NFC_ISR.B.ECCBN)
#endif
//@}

/*!
 * @name Register NFC_ISR, field RESBN[5:4] (RO)
 *
 * Buffer number corresponding with the current residue block task.
 */
//@{
#define BP_NFC_ISR_RESBN     (4U)          //!< Bit position for NFC_ISR_RESBN.
#define BM_NFC_ISR_RESBN     (0x00000030U) //!< Bit mask for NFC_ISR_RESBN.
#define BS_NFC_ISR_RESBN     (2U)          //!< Bit field size in bits for NFC_ISR_RESBN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_ISR_RESBN field.
#define BR_NFC_ISR_RESBN     (HW_NFC_ISR.B.RESBN)
#endif
//@}

/*!
 * @name Register NFC_ISR, field IDLECLR[17] (W1C)
 *
 * Clear bit for NFC_ISR[IDLE]. Writing 1 to this bit clears NFC_ISR[IDLE].
 */
//@{
#define BP_NFC_ISR_IDLECLR   (17U)         //!< Bit position for NFC_ISR_IDLECLR.
#define BM_NFC_ISR_IDLECLR   (0x00020000U) //!< Bit mask for NFC_ISR_IDLECLR.
#define BS_NFC_ISR_IDLECLR   (1U)          //!< Bit field size in bits for NFC_ISR_IDLECLR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_ISR_IDLECLR field.
#define BR_NFC_ISR_IDLECLR   (BITBAND_ACCESS32(HW_NFC_ISR_ADDR, BP_NFC_ISR_IDLECLR))
#endif

//! @brief Format value for bitfield NFC_ISR_IDLECLR.
#define BF_NFC_ISR_IDLECLR(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_ISR_IDLECLR), uint32_t) & BM_NFC_ISR_IDLECLR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the IDLECLR field to a new value.
#define BW_NFC_ISR_IDLECLR(v) (BITBAND_ACCESS32(HW_NFC_ISR_ADDR, BP_NFC_ISR_IDLECLR) = (v))
#endif
//@}

/*!
 * @name Register NFC_ISR, field DONECLR[18] (W1C)
 *
 * Clear bit for NFC_ISR[DONE]. Writing 1 to this bit clears NFC_ISR[DONE].
 */
//@{
#define BP_NFC_ISR_DONECLR   (18U)         //!< Bit position for NFC_ISR_DONECLR.
#define BM_NFC_ISR_DONECLR   (0x00040000U) //!< Bit mask for NFC_ISR_DONECLR.
#define BS_NFC_ISR_DONECLR   (1U)          //!< Bit field size in bits for NFC_ISR_DONECLR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_ISR_DONECLR field.
#define BR_NFC_ISR_DONECLR   (BITBAND_ACCESS32(HW_NFC_ISR_ADDR, BP_NFC_ISR_DONECLR))
#endif

//! @brief Format value for bitfield NFC_ISR_DONECLR.
#define BF_NFC_ISR_DONECLR(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_ISR_DONECLR), uint32_t) & BM_NFC_ISR_DONECLR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONECLR field to a new value.
#define BW_NFC_ISR_DONECLR(v) (BITBAND_ACCESS32(HW_NFC_ISR_ADDR, BP_NFC_ISR_DONECLR) = (v))
#endif
//@}

/*!
 * @name Register NFC_ISR, field WERRCLR[19] (W1C)
 *
 * Clear bit for NFC_ISR[WERR]. Writing 1 to this bit clears NFC_ISR[WERR].
 */
//@{
#define BP_NFC_ISR_WERRCLR   (19U)         //!< Bit position for NFC_ISR_WERRCLR.
#define BM_NFC_ISR_WERRCLR   (0x00080000U) //!< Bit mask for NFC_ISR_WERRCLR.
#define BS_NFC_ISR_WERRCLR   (1U)          //!< Bit field size in bits for NFC_ISR_WERRCLR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_ISR_WERRCLR field.
#define BR_NFC_ISR_WERRCLR   (BITBAND_ACCESS32(HW_NFC_ISR_ADDR, BP_NFC_ISR_WERRCLR))
#endif

//! @brief Format value for bitfield NFC_ISR_WERRCLR.
#define BF_NFC_ISR_WERRCLR(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_ISR_WERRCLR), uint32_t) & BM_NFC_ISR_WERRCLR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the WERRCLR field to a new value.
#define BW_NFC_ISR_WERRCLR(v) (BITBAND_ACCESS32(HW_NFC_ISR_ADDR, BP_NFC_ISR_WERRCLR) = (v))
#endif
//@}

/*!
 * @name Register NFC_ISR, field IDLEEN[20] (RW)
 *
 * Enable bit for NFC_ISR[IDLE]
 */
//@{
#define BP_NFC_ISR_IDLEEN    (20U)         //!< Bit position for NFC_ISR_IDLEEN.
#define BM_NFC_ISR_IDLEEN    (0x00100000U) //!< Bit mask for NFC_ISR_IDLEEN.
#define BS_NFC_ISR_IDLEEN    (1U)          //!< Bit field size in bits for NFC_ISR_IDLEEN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_ISR_IDLEEN field.
#define BR_NFC_ISR_IDLEEN    (BITBAND_ACCESS32(HW_NFC_ISR_ADDR, BP_NFC_ISR_IDLEEN))
#endif

//! @brief Format value for bitfield NFC_ISR_IDLEEN.
#define BF_NFC_ISR_IDLEEN(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_ISR_IDLEEN), uint32_t) & BM_NFC_ISR_IDLEEN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the IDLEEN field to a new value.
#define BW_NFC_ISR_IDLEEN(v) (BITBAND_ACCESS32(HW_NFC_ISR_ADDR, BP_NFC_ISR_IDLEEN) = (v))
#endif
//@}

/*!
 * @name Register NFC_ISR, field DONEEN[21] (RW)
 *
 * Enable bit for NFC_ISR[DONE]
 */
//@{
#define BP_NFC_ISR_DONEEN    (21U)         //!< Bit position for NFC_ISR_DONEEN.
#define BM_NFC_ISR_DONEEN    (0x00200000U) //!< Bit mask for NFC_ISR_DONEEN.
#define BS_NFC_ISR_DONEEN    (1U)          //!< Bit field size in bits for NFC_ISR_DONEEN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_ISR_DONEEN field.
#define BR_NFC_ISR_DONEEN    (BITBAND_ACCESS32(HW_NFC_ISR_ADDR, BP_NFC_ISR_DONEEN))
#endif

//! @brief Format value for bitfield NFC_ISR_DONEEN.
#define BF_NFC_ISR_DONEEN(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_ISR_DONEEN), uint32_t) & BM_NFC_ISR_DONEEN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DONEEN field to a new value.
#define BW_NFC_ISR_DONEEN(v) (BITBAND_ACCESS32(HW_NFC_ISR_ADDR, BP_NFC_ISR_DONEEN) = (v))
#endif
//@}

/*!
 * @name Register NFC_ISR, field WERREN[22] (RW)
 *
 * Enable bit for NFC_ISR[WERR]
 */
//@{
#define BP_NFC_ISR_WERREN    (22U)         //!< Bit position for NFC_ISR_WERREN.
#define BM_NFC_ISR_WERREN    (0x00400000U) //!< Bit mask for NFC_ISR_WERREN.
#define BS_NFC_ISR_WERREN    (1U)          //!< Bit field size in bits for NFC_ISR_WERREN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_ISR_WERREN field.
#define BR_NFC_ISR_WERREN    (BITBAND_ACCESS32(HW_NFC_ISR_ADDR, BP_NFC_ISR_WERREN))
#endif

//! @brief Format value for bitfield NFC_ISR_WERREN.
#define BF_NFC_ISR_WERREN(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_NFC_ISR_WERREN), uint32_t) & BM_NFC_ISR_WERREN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the WERREN field to a new value.
#define BW_NFC_ISR_WERREN(v) (BITBAND_ACCESS32(HW_NFC_ISR_ADDR, BP_NFC_ISR_WERREN) = (v))
#endif
//@}

/*!
 * @name Register NFC_ISR, field DMABUSY[23] (RO)
 *
 * Set if DMA engine busy, cleared otherwise.
 */
//@{
#define BP_NFC_ISR_DMABUSY   (23U)         //!< Bit position for NFC_ISR_DMABUSY.
#define BM_NFC_ISR_DMABUSY   (0x00800000U) //!< Bit mask for NFC_ISR_DMABUSY.
#define BS_NFC_ISR_DMABUSY   (1U)          //!< Bit field size in bits for NFC_ISR_DMABUSY.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_ISR_DMABUSY field.
#define BR_NFC_ISR_DMABUSY   (BITBAND_ACCESS32(HW_NFC_ISR_ADDR, BP_NFC_ISR_DMABUSY))
#endif
//@}

/*!
 * @name Register NFC_ISR, field ECCBUSY[24] (RO)
 *
 * Set if ECC engine busy, cleared otherwise.
 */
//@{
#define BP_NFC_ISR_ECCBUSY   (24U)         //!< Bit position for NFC_ISR_ECCBUSY.
#define BM_NFC_ISR_ECCBUSY   (0x01000000U) //!< Bit mask for NFC_ISR_ECCBUSY.
#define BS_NFC_ISR_ECCBUSY   (1U)          //!< Bit field size in bits for NFC_ISR_ECCBUSY.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_ISR_ECCBUSY field.
#define BR_NFC_ISR_ECCBUSY   (BITBAND_ACCESS32(HW_NFC_ISR_ADDR, BP_NFC_ISR_ECCBUSY))
#endif
//@}

/*!
 * @name Register NFC_ISR, field RESBUSY[25] (RO)
 *
 * Set if residue engine busy, cleared otherwise.
 */
//@{
#define BP_NFC_ISR_RESBUSY   (25U)         //!< Bit position for NFC_ISR_RESBUSY.
#define BM_NFC_ISR_RESBUSY   (0x02000000U) //!< Bit mask for NFC_ISR_RESBUSY.
#define BS_NFC_ISR_RESBUSY   (1U)          //!< Bit field size in bits for NFC_ISR_RESBUSY.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_ISR_RESBUSY field.
#define BR_NFC_ISR_RESBUSY   (BITBAND_ACCESS32(HW_NFC_ISR_ADDR, BP_NFC_ISR_RESBUSY))
#endif
//@}

/*!
 * @name Register NFC_ISR, field CMDBUSY[26] (RO)
 *
 * Set it command execution busy, cleared otherwise.
 */
//@{
#define BP_NFC_ISR_CMDBUSY   (26U)         //!< Bit position for NFC_ISR_CMDBUSY.
#define BM_NFC_ISR_CMDBUSY   (0x04000000U) //!< Bit mask for NFC_ISR_CMDBUSY.
#define BS_NFC_ISR_CMDBUSY   (1U)          //!< Bit field size in bits for NFC_ISR_CMDBUSY.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_ISR_CMDBUSY field.
#define BR_NFC_ISR_CMDBUSY   (BITBAND_ACCESS32(HW_NFC_ISR_ADDR, BP_NFC_ISR_CMDBUSY))
#endif
//@}

/*!
 * @name Register NFC_ISR, field WERRNS[27] (RO)
 *
 * Set if an error condition was detected during the last flash read status
 * command. Non-sticky bit.
 */
//@{
#define BP_NFC_ISR_WERRNS    (27U)         //!< Bit position for NFC_ISR_WERRNS.
#define BM_NFC_ISR_WERRNS    (0x08000000U) //!< Bit mask for NFC_ISR_WERRNS.
#define BS_NFC_ISR_WERRNS    (1U)          //!< Bit field size in bits for NFC_ISR_WERRNS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_ISR_WERRNS field.
#define BR_NFC_ISR_WERRNS    (BITBAND_ACCESS32(HW_NFC_ISR_ADDR, BP_NFC_ISR_WERRNS))
#endif
//@}

/*!
 * @name Register NFC_ISR, field IDLE[29] (RO)
 *
 * Set if command done, and residue engine, ECC engine and DMA engine are idle.
 */
//@{
#define BP_NFC_ISR_IDLE      (29U)         //!< Bit position for NFC_ISR_IDLE.
#define BM_NFC_ISR_IDLE      (0x20000000U) //!< Bit mask for NFC_ISR_IDLE.
#define BS_NFC_ISR_IDLE      (1U)          //!< Bit field size in bits for NFC_ISR_IDLE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_ISR_IDLE field.
#define BR_NFC_ISR_IDLE      (BITBAND_ACCESS32(HW_NFC_ISR_ADDR, BP_NFC_ISR_IDLE))
#endif
//@}

/*!
 * @name Register NFC_ISR, field DONE[30] (RO)
 *
 * Set if command processing is done.
 */
//@{
#define BP_NFC_ISR_DONE      (30U)         //!< Bit position for NFC_ISR_DONE.
#define BM_NFC_ISR_DONE      (0x40000000U) //!< Bit mask for NFC_ISR_DONE.
#define BS_NFC_ISR_DONE      (1U)          //!< Bit field size in bits for NFC_ISR_DONE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_ISR_DONE field.
#define BR_NFC_ISR_DONE      (BITBAND_ACCESS32(HW_NFC_ISR_ADDR, BP_NFC_ISR_DONE))
#endif
//@}

/*!
 * @name Register NFC_ISR, field WERR[31] (RO)
 *
 * Set if an error condition is detected during a flash read status command.
 * Sticky bit.
 */
//@{
#define BP_NFC_ISR_WERR      (31U)         //!< Bit position for NFC_ISR_WERR.
#define BM_NFC_ISR_WERR      (0x80000000U) //!< Bit mask for NFC_ISR_WERR.
#define BS_NFC_ISR_WERR      (1U)          //!< Bit field size in bits for NFC_ISR_WERR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the NFC_ISR_WERR field.
#define BR_NFC_ISR_WERR      (BITBAND_ACCESS32(HW_NFC_ISR_ADDR, BP_NFC_ISR_WERR))
#endif
//@}

//-------------------------------------------------------------------------------------------
// hw_nfc_t - module struct
//-------------------------------------------------------------------------------------------
/*!
 * @brief All NFC module registers.
 */
#ifndef __LANGUAGE_ASM__
#pragma pack(1)
typedef struct _hw_nfc
{
    uint8_t _reserved0[16128];
    __IO hw_nfc_cmd1_t CMD1;               //!< [0x3F00] Flash command 1
    __IO hw_nfc_cmd2_t CMD2;               //!< [0x3F04] Flash command 2
    __IO hw_nfc_car_t CAR;                 //!< [0x3F08] Column address
    __IO hw_nfc_rar_t RAR;                 //!< [0x3F0C] Row address
    __IO hw_nfc_rpt_t RPT;                 //!< [0x3F10] Flash command repeat
    __IO hw_nfc_rai_t RAI;                 //!< [0x3F14] Row address increment
    __I hw_nfc_sr1_t SR1;                  //!< [0x3F18] Flash status 1
    __I hw_nfc_sr2_t SR2;                  //!< [0x3F1C] Flash status 2
    __IO hw_nfc_dma1_t DMA1;               //!< [0x3F20] DMA channel 1 address
    __IO hw_nfc_dmacfg_t DMACFG;           //!< [0x3F24] DMA configuration
    __IO hw_nfc_swap_t SWAP;               //!< [0x3F28] Cach swap
    __IO hw_nfc_secsz_t SECSZ;             //!< [0x3F2C] Sector size
    __IO hw_nfc_cfg_t CFG;                 //!< [0x3F30] Flash configuration
    __IO hw_nfc_dma2_t DMA2;               //!< [0x3F34] DMA channel 2 address
    __IO hw_nfc_isr_t ISR;                 //!< [0x3F38] Interrupt status
} hw_nfc_t;
#pragma pack()

//! @brief Macro to access all NFC registers.
//! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
//!     use the '&' operator, like <code>&HW_NFC</code>.
#define HW_NFC         (*(hw_nfc_t *) REGS_NFC_BASE)
#endif

#endif // __HW_NFC_REGISTERS_H__
// v22/130726/0.9
// EOF

/*
 * Copyright (c) 2014, Freescale Semiconductor, Inc.
 * All rights reserved.
 *
 * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL FREESCALE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */
/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_FTFL_REGISTERS_H__
#define __HW_FTFL_REGISTERS_H__

#include "regs.h"

/*
 * MK20D5 FTFL
 *
 * Flash Memory Interface
 *
 * Registers defined in this header file:
 * - HW_FTFL_FSTAT - Flash Status Register
 * - HW_FTFL_FCNFG - Flash Configuration Register
 * - HW_FTFL_FSEC - Flash Security Register
 * - HW_FTFL_FOPT - Flash Option Register
 * - HW_FTFL_FCCOB3 - Flash Common Command Object Registers
 * - HW_FTFL_FCCOB2 - Flash Common Command Object Registers
 * - HW_FTFL_FCCOB1 - Flash Common Command Object Registers
 * - HW_FTFL_FCCOB0 - Flash Common Command Object Registers
 * - HW_FTFL_FCCOB7 - Flash Common Command Object Registers
 * - HW_FTFL_FCCOB6 - Flash Common Command Object Registers
 * - HW_FTFL_FCCOB5 - Flash Common Command Object Registers
 * - HW_FTFL_FCCOB4 - Flash Common Command Object Registers
 * - HW_FTFL_FCCOBB - Flash Common Command Object Registers
 * - HW_FTFL_FCCOBA - Flash Common Command Object Registers
 * - HW_FTFL_FCCOB9 - Flash Common Command Object Registers
 * - HW_FTFL_FCCOB8 - Flash Common Command Object Registers
 * - HW_FTFL_FPROT3 - Program Flash Protection Registers
 * - HW_FTFL_FPROT2 - Program Flash Protection Registers
 * - HW_FTFL_FPROT1 - Program Flash Protection Registers
 * - HW_FTFL_FPROT0 - Program Flash Protection Registers
 * - HW_FTFL_FEPROT - EEPROM Protection Register
 * - HW_FTFL_FDPROT - Data Flash Protection Register
 *
 * - hw_ftfl_t - Struct containing all module registers.
 */

//! @name Module base addresses
//@{
#ifndef REGS_FTFL_BASE
#define HW_FTFL_INSTANCE_COUNT (1U) //!< Number of instances of the FTFL module.
#define REGS_FTFL_BASE (0x40020000U) //!< Base address for FTFL.
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_FTFL_FSTAT - Flash Status Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_FTFL_FSTAT - Flash Status Register (RW)
 *
 * Reset value: 0x00U
 *
 * The FSTAT register reports the operational status of the FTFL module. The
 * CCIF, RDCOLERR, ACCERR, and FPVIOL bits are readable and writable. The MGSTAT0
 * bit is read only. The unassigned bits read 0 and are not writable. When set, the
 * Access Error (ACCERR) and Flash Protection Violation (FPVIOL) bits in this
 * register prevent the launch of any more commands until the flag is cleared (by
 * writing a one to it).
 */
typedef union _hw_ftfl_fstat
{
    uint8_t U;
    struct _hw_ftfl_fstat_bitfields
    {
        uint8_t MGSTAT0 : 1;           //!< [0] Memory Controller Command Completion
                                       //! Status Flag
        uint8_t RESERVED0 : 3;         //!< [3:1]
        uint8_t FPVIOL : 1;            //!< [4] Flash Protection Violation Flag
        uint8_t ACCERR : 1;            //!< [5] Flash Access Error Flag
        uint8_t RDCOLERR : 1;          //!< [6] FTFL Read Collision Error Flag
        uint8_t CCIF : 1;              //!< [7] Command Complete Interrupt Flag
    } B;
} hw_ftfl_fstat_t;
#endif

/*!
 * @name Constants and macros for entire FTFL_FSTAT register
 */
//@{
#define HW_FTFL_FSTAT_ADDR       (REGS_FTFL_BASE + 0x0U)

#ifndef __LANGUAGE_ASM__
#define HW_FTFL_FSTAT            (*(__IO hw_ftfl_fstat_t *) HW_FTFL_FSTAT_ADDR)
#define HW_FTFL_FSTAT_RD()       (HW_FTFL_FSTAT.U)
#define HW_FTFL_FSTAT_WR(v)      (HW_FTFL_FSTAT.U = (v))
#define HW_FTFL_FSTAT_SET(v)     (HW_FTFL_FSTAT_WR(HW_FTFL_FSTAT_RD() |  (v)))
#define HW_FTFL_FSTAT_CLR(v)     (HW_FTFL_FSTAT_WR(HW_FTFL_FSTAT_RD() & ~(v)))
#define HW_FTFL_FSTAT_TOG(v)     (HW_FTFL_FSTAT_WR(HW_FTFL_FSTAT_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual FTFL_FSTAT bitfields
 */

/*!
 * @name Register FTFL_FSTAT, field MGSTAT0[0] (RO)
 *
 * The MGSTAT0 status flag is set if an error is detected during execution of an
 * FTFL command or during the flash reset sequence. As a status flag, this bit
 * cannot (and need not) be cleared by the user like the other error flags in this
 * register. The value of the MGSTAT0 bit for "command-N" is valid only at the
 * end of the "command-N" execution when CCIF=1 and before the next command has
 * been launched. At some point during the execution of "command-N+1," the previous
 * result is discarded and any previous error is cleared.
 */
//@{
#define BP_FTFL_FSTAT_MGSTAT0 (0U)         //!< Bit position for FTFL_FSTAT_MGSTAT0.
#define BM_FTFL_FSTAT_MGSTAT0 (0x01U)      //!< Bit mask for FTFL_FSTAT_MGSTAT0.
#define BS_FTFL_FSTAT_MGSTAT0 (1U)         //!< Bit field size in bits for FTFL_FSTAT_MGSTAT0.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FSTAT_MGSTAT0 field.
#define BR_FTFL_FSTAT_MGSTAT0 (BITBAND_ACCESS8(HW_FTFL_FSTAT_ADDR, BP_FTFL_FSTAT_MGSTAT0))
#endif
//@}

/*!
 * @name Register FTFL_FSTAT, field FPVIOL[4] (W1C)
 *
 * The FPVIOL error bit indicates an attempt was made to program or erase an
 * address in a protected area of program flash or data flash memory during a
 * command write sequence or a write was attempted to a protected area of the FlexRAM
 * while enabled for EEPROM . While FPVIOL is set, the CCIF flag cannot be cleared
 * to launch a command. The FPVIOL bit is cleared by writing a 1 to it. Writing
 * a 0 to the FPVIOL bit has no effect.
 *
 * Values:
 * - 0 - No protection violation detected
 * - 1 - Protection violation detected
 */
//@{
#define BP_FTFL_FSTAT_FPVIOL (4U)          //!< Bit position for FTFL_FSTAT_FPVIOL.
#define BM_FTFL_FSTAT_FPVIOL (0x10U)       //!< Bit mask for FTFL_FSTAT_FPVIOL.
#define BS_FTFL_FSTAT_FPVIOL (1U)          //!< Bit field size in bits for FTFL_FSTAT_FPVIOL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FSTAT_FPVIOL field.
#define BR_FTFL_FSTAT_FPVIOL (BITBAND_ACCESS8(HW_FTFL_FSTAT_ADDR, BP_FTFL_FSTAT_FPVIOL))
#endif

//! @brief Format value for bitfield FTFL_FSTAT_FPVIOL.
#define BF_FTFL_FSTAT_FPVIOL(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FSTAT_FPVIOL), uint8_t) & BM_FTFL_FSTAT_FPVIOL)

#ifndef __LANGUAGE_ASM__
//! @brief Set the FPVIOL field to a new value.
#define BW_FTFL_FSTAT_FPVIOL(v) (BITBAND_ACCESS8(HW_FTFL_FSTAT_ADDR, BP_FTFL_FSTAT_FPVIOL) = (v))
#endif
//@}

/*!
 * @name Register FTFL_FSTAT, field ACCERR[5] (W1C)
 *
 * The ACCERR error bit indicates an illegal access has occurred to an FTFL
 * resource caused by a violation of the command write sequence or issuing an illegal
 * FTFL command. While ACCERR is set, the CCIF flag cannot be cleared to launch
 * a command. The ACCERR bit is cleared by writing a 1 to it. Writing a 0 to the
 * ACCERR bit has no effect.
 *
 * Values:
 * - 0 - No access error detected
 * - 1 - Access error detected
 */
//@{
#define BP_FTFL_FSTAT_ACCERR (5U)          //!< Bit position for FTFL_FSTAT_ACCERR.
#define BM_FTFL_FSTAT_ACCERR (0x20U)       //!< Bit mask for FTFL_FSTAT_ACCERR.
#define BS_FTFL_FSTAT_ACCERR (1U)          //!< Bit field size in bits for FTFL_FSTAT_ACCERR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FSTAT_ACCERR field.
#define BR_FTFL_FSTAT_ACCERR (BITBAND_ACCESS8(HW_FTFL_FSTAT_ADDR, BP_FTFL_FSTAT_ACCERR))
#endif

//! @brief Format value for bitfield FTFL_FSTAT_ACCERR.
#define BF_FTFL_FSTAT_ACCERR(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FSTAT_ACCERR), uint8_t) & BM_FTFL_FSTAT_ACCERR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACCERR field to a new value.
#define BW_FTFL_FSTAT_ACCERR(v) (BITBAND_ACCESS8(HW_FTFL_FSTAT_ADDR, BP_FTFL_FSTAT_ACCERR) = (v))
#endif
//@}

/*!
 * @name Register FTFL_FSTAT, field RDCOLERR[6] (W1C)
 *
 * The RDCOLERR error bit indicates that the MCU attempted a read from an FTFL
 * resource that was being manipulated by an FTFL command (CCIF=0). Any
 * simultaneous access is detected as a collision error by the block arbitration logic. The
 * read data in this case cannot be guaranteed. The RDCOLERR bit is cleared by
 * writing a 1 to it. Writing a 0 to RDCOLERR has no effect.
 *
 * Values:
 * - 0 - No collision error detected
 * - 1 - Collision error detected
 */
//@{
#define BP_FTFL_FSTAT_RDCOLERR (6U)        //!< Bit position for FTFL_FSTAT_RDCOLERR.
#define BM_FTFL_FSTAT_RDCOLERR (0x40U)     //!< Bit mask for FTFL_FSTAT_RDCOLERR.
#define BS_FTFL_FSTAT_RDCOLERR (1U)        //!< Bit field size in bits for FTFL_FSTAT_RDCOLERR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FSTAT_RDCOLERR field.
#define BR_FTFL_FSTAT_RDCOLERR (BITBAND_ACCESS8(HW_FTFL_FSTAT_ADDR, BP_FTFL_FSTAT_RDCOLERR))
#endif

//! @brief Format value for bitfield FTFL_FSTAT_RDCOLERR.
#define BF_FTFL_FSTAT_RDCOLERR(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FSTAT_RDCOLERR), uint8_t) & BM_FTFL_FSTAT_RDCOLERR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RDCOLERR field to a new value.
#define BW_FTFL_FSTAT_RDCOLERR(v) (BITBAND_ACCESS8(HW_FTFL_FSTAT_ADDR, BP_FTFL_FSTAT_RDCOLERR) = (v))
#endif
//@}

/*!
 * @name Register FTFL_FSTAT, field CCIF[7] (W1C)
 *
 * The CCIF flag indicates that a FTFL command or EEPROM file system operation
 * has completed. The CCIF flag is cleared by writing a 1 to CCIF to launch a
 * command, and CCIF stays low until command completion or command violation. The
 * CCIF flag is also cleared by a successful write to FlexRAM while enabled for EEE,
 * and CCIF stays low until the EEPROM file system has created the associated
 * EEPROM data record. The CCIF bit is reset to 0 but is set to 1 by the memory
 * controller at the end of the reset initialization sequence. Depending on how
 * quickly the read occurs after reset release, the user may or may not see the 0
 * hardware reset value.
 *
 * Values:
 * - 0 - FTFL command or EEPROM file system operation in progress
 * - 1 - FTFL command or EEPROM file system operation has completed
 */
//@{
#define BP_FTFL_FSTAT_CCIF   (7U)          //!< Bit position for FTFL_FSTAT_CCIF.
#define BM_FTFL_FSTAT_CCIF   (0x80U)       //!< Bit mask for FTFL_FSTAT_CCIF.
#define BS_FTFL_FSTAT_CCIF   (1U)          //!< Bit field size in bits for FTFL_FSTAT_CCIF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FSTAT_CCIF field.
#define BR_FTFL_FSTAT_CCIF   (BITBAND_ACCESS8(HW_FTFL_FSTAT_ADDR, BP_FTFL_FSTAT_CCIF))
#endif

//! @brief Format value for bitfield FTFL_FSTAT_CCIF.
#define BF_FTFL_FSTAT_CCIF(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FSTAT_CCIF), uint8_t) & BM_FTFL_FSTAT_CCIF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CCIF field to a new value.
#define BW_FTFL_FSTAT_CCIF(v) (BITBAND_ACCESS8(HW_FTFL_FSTAT_ADDR, BP_FTFL_FSTAT_CCIF) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_FTFL_FCNFG - Flash Configuration Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_FTFL_FCNFG - Flash Configuration Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides information on the current functional state of the
 * FTFL module. The erase control bits (ERSAREQ and ERSSUSP) have write
 * restrictions. RAMRDY , and EEERDY are read-only status bits . The unassigned bits read as
 * noted and are not writable. The reset values for the RAMRDY , and EEERDY bits
 * are determined during the reset sequence.
 */
typedef union _hw_ftfl_fcnfg
{
    uint8_t U;
    struct _hw_ftfl_fcnfg_bitfields
    {
        uint8_t EEERDY : 1;            //!< [0]
        uint8_t RAMRDY : 1;            //!< [1] RAM Ready
        uint8_t PFLSH : 1;             //!< [2] FTFL configuration
        uint8_t RESERVED0 : 1;         //!< [3]
        uint8_t ERSSUSP : 1;           //!< [4] Erase Suspend
        uint8_t ERSAREQ : 1;           //!< [5] Erase All Request
        uint8_t RDCOLLIE : 1;          //!< [6] Read Collision Error Interrupt Enable
        uint8_t CCIE : 1;              //!< [7] Command Complete Interrupt Enable
    } B;
} hw_ftfl_fcnfg_t;
#endif

/*!
 * @name Constants and macros for entire FTFL_FCNFG register
 */
//@{
#define HW_FTFL_FCNFG_ADDR       (REGS_FTFL_BASE + 0x1U)

#ifndef __LANGUAGE_ASM__
#define HW_FTFL_FCNFG            (*(__IO hw_ftfl_fcnfg_t *) HW_FTFL_FCNFG_ADDR)
#define HW_FTFL_FCNFG_RD()       (HW_FTFL_FCNFG.U)
#define HW_FTFL_FCNFG_WR(v)      (HW_FTFL_FCNFG.U = (v))
#define HW_FTFL_FCNFG_SET(v)     (HW_FTFL_FCNFG_WR(HW_FTFL_FCNFG_RD() |  (v)))
#define HW_FTFL_FCNFG_CLR(v)     (HW_FTFL_FCNFG_WR(HW_FTFL_FCNFG_RD() & ~(v)))
#define HW_FTFL_FCNFG_TOG(v)     (HW_FTFL_FCNFG_WR(HW_FTFL_FCNFG_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual FTFL_FCNFG bitfields
 */

/*!
 * @name Register FTFL_FCNFG, field EEERDY[0] (RO)
 *
 * This flag indicates if the EEPROM backup data has been copied to the FlexRAM
 * and is therefore available for read access.
 *
 * Values:
 * - 0 - FlexRAM is not available for EEPROM operation.
 * - 1 - FlexRAM is available for EEPROM operations where: reads from the
 *     FlexRAM return data previously written to the FlexRAM in EEPROM mode and writes
 *     to the FlexRAM clear EEERDY and launch an EEPROM operation to store the
 *     written data in the FlexRAM and EEPROM backup.
 */
//@{
#define BP_FTFL_FCNFG_EEERDY (0U)          //!< Bit position for FTFL_FCNFG_EEERDY.
#define BM_FTFL_FCNFG_EEERDY (0x01U)       //!< Bit mask for FTFL_FCNFG_EEERDY.
#define BS_FTFL_FCNFG_EEERDY (1U)          //!< Bit field size in bits for FTFL_FCNFG_EEERDY.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FCNFG_EEERDY field.
#define BR_FTFL_FCNFG_EEERDY (BITBAND_ACCESS8(HW_FTFL_FCNFG_ADDR, BP_FTFL_FCNFG_EEERDY))
#endif
//@}

/*!
 * @name Register FTFL_FCNFG, field RAMRDY[1] (RO)
 *
 * This flag indicates the current status of the FlexRAM . The state of the
 * RAMRDY flag is normally controlled by the Set FlexRAM Function command. During the
 * reset sequence, the RAMRDY flag is cleared if the FlexNVM block is
 * partitioned for EEPROM and is set if the FlexNVM block is not partitioned for EEPROM.
 * The RAMRDY flag is cleared if the Program Partition command is run to partition
 * the FlexNVM block for EEPROM. The RAMRDY flag sets after completion of the
 * Erase All Blocks command or execution of the erase-all operation triggered
 * external to the FTFL .
 *
 * Values:
 * - 0 - FlexRAM is not available for traditional RAM access.
 * - 1 - FlexRAM is available as traditional RAM only; writes to the FlexRAM do
 *     not trigger EEPROM operations.
 */
//@{
#define BP_FTFL_FCNFG_RAMRDY (1U)          //!< Bit position for FTFL_FCNFG_RAMRDY.
#define BM_FTFL_FCNFG_RAMRDY (0x02U)       //!< Bit mask for FTFL_FCNFG_RAMRDY.
#define BS_FTFL_FCNFG_RAMRDY (1U)          //!< Bit field size in bits for FTFL_FCNFG_RAMRDY.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FCNFG_RAMRDY field.
#define BR_FTFL_FCNFG_RAMRDY (BITBAND_ACCESS8(HW_FTFL_FCNFG_ADDR, BP_FTFL_FCNFG_RAMRDY))
#endif
//@}

/*!
 * @name Register FTFL_FCNFG, field PFLSH[2] (RO)
 *
 * Values:
 * - 0 - FTFL configured for FlexMemory that supports data flash and/or EEPROM
 * - 1 - Reserved
 */
//@{
#define BP_FTFL_FCNFG_PFLSH  (2U)          //!< Bit position for FTFL_FCNFG_PFLSH.
#define BM_FTFL_FCNFG_PFLSH  (0x04U)       //!< Bit mask for FTFL_FCNFG_PFLSH.
#define BS_FTFL_FCNFG_PFLSH  (1U)          //!< Bit field size in bits for FTFL_FCNFG_PFLSH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FCNFG_PFLSH field.
#define BR_FTFL_FCNFG_PFLSH  (BITBAND_ACCESS8(HW_FTFL_FCNFG_ADDR, BP_FTFL_FCNFG_PFLSH))
#endif
//@}

/*!
 * @name Register FTFL_FCNFG, field ERSSUSP[4] (RW)
 *
 * The ERSSUSP bit allows the user to suspend (interrupt) the Erase Flash Sector
 * command while it is executing.
 *
 * Values:
 * - 0 - No suspend requested
 * - 1 - Suspend the current Erase Flash Sector command execution.
 */
//@{
#define BP_FTFL_FCNFG_ERSSUSP (4U)         //!< Bit position for FTFL_FCNFG_ERSSUSP.
#define BM_FTFL_FCNFG_ERSSUSP (0x10U)      //!< Bit mask for FTFL_FCNFG_ERSSUSP.
#define BS_FTFL_FCNFG_ERSSUSP (1U)         //!< Bit field size in bits for FTFL_FCNFG_ERSSUSP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FCNFG_ERSSUSP field.
#define BR_FTFL_FCNFG_ERSSUSP (BITBAND_ACCESS8(HW_FTFL_FCNFG_ADDR, BP_FTFL_FCNFG_ERSSUSP))
#endif

//! @brief Format value for bitfield FTFL_FCNFG_ERSSUSP.
#define BF_FTFL_FCNFG_ERSSUSP(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FCNFG_ERSSUSP), uint8_t) & BM_FTFL_FCNFG_ERSSUSP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERSSUSP field to a new value.
#define BW_FTFL_FCNFG_ERSSUSP(v) (BITBAND_ACCESS8(HW_FTFL_FCNFG_ADDR, BP_FTFL_FCNFG_ERSSUSP) = (v))
#endif
//@}

/*!
 * @name Register FTFL_FCNFG, field ERSAREQ[5] (RO)
 *
 * This bit issues a request to the memory controller to execute the Erase All
 * Blocks command and release security. ERSAREQ is not directly writable but is
 * under indirect user control. Refer to the device's Chip Configuration details on
 * how to request this command. The ERSAREQ bit sets when an erase all request
 * is triggered external to the FTFL and CCIF is set (no command is currently
 * being executed). ERSAREQ is cleared by the FTFL when the operation completes.
 *
 * Values:
 * - 0 - No request or request complete
 * - 1 - Request to: run the Erase All Blocks command, verify the erased state,
 *     program the security byte in the Flash Configuration Field to the unsecure
 *     state, and release MCU security by setting the FSEC[SEC] field to the
 *     unsecure state.
 */
//@{
#define BP_FTFL_FCNFG_ERSAREQ (5U)         //!< Bit position for FTFL_FCNFG_ERSAREQ.
#define BM_FTFL_FCNFG_ERSAREQ (0x20U)      //!< Bit mask for FTFL_FCNFG_ERSAREQ.
#define BS_FTFL_FCNFG_ERSAREQ (1U)         //!< Bit field size in bits for FTFL_FCNFG_ERSAREQ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FCNFG_ERSAREQ field.
#define BR_FTFL_FCNFG_ERSAREQ (BITBAND_ACCESS8(HW_FTFL_FCNFG_ADDR, BP_FTFL_FCNFG_ERSAREQ))
#endif
//@}

/*!
 * @name Register FTFL_FCNFG, field RDCOLLIE[6] (RW)
 *
 * The RDCOLLIE bit controls interrupt generation when an FTFL read collision
 * error occurs.
 *
 * Values:
 * - 0 - Read collision error interrupt disabled
 * - 1 - Read collision error interrupt enabled. An interrupt request is
 *     generated whenever an FTFL read collision error is detected (see the description
 *     of FSTAT[RDCOLERR]).
 */
//@{
#define BP_FTFL_FCNFG_RDCOLLIE (6U)        //!< Bit position for FTFL_FCNFG_RDCOLLIE.
#define BM_FTFL_FCNFG_RDCOLLIE (0x40U)     //!< Bit mask for FTFL_FCNFG_RDCOLLIE.
#define BS_FTFL_FCNFG_RDCOLLIE (1U)        //!< Bit field size in bits for FTFL_FCNFG_RDCOLLIE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FCNFG_RDCOLLIE field.
#define BR_FTFL_FCNFG_RDCOLLIE (BITBAND_ACCESS8(HW_FTFL_FCNFG_ADDR, BP_FTFL_FCNFG_RDCOLLIE))
#endif

//! @brief Format value for bitfield FTFL_FCNFG_RDCOLLIE.
#define BF_FTFL_FCNFG_RDCOLLIE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FCNFG_RDCOLLIE), uint8_t) & BM_FTFL_FCNFG_RDCOLLIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RDCOLLIE field to a new value.
#define BW_FTFL_FCNFG_RDCOLLIE(v) (BITBAND_ACCESS8(HW_FTFL_FCNFG_ADDR, BP_FTFL_FCNFG_RDCOLLIE) = (v))
#endif
//@}

/*!
 * @name Register FTFL_FCNFG, field CCIE[7] (RW)
 *
 * The CCIE bit controls interrupt generation when an FTFL command completes.
 *
 * Values:
 * - 0 - Command complete interrupt disabled
 * - 1 - Command complete interrupt enabled. An interrupt request is generated
 *     whenever the FSTAT[CCIF] flag is set.
 */
//@{
#define BP_FTFL_FCNFG_CCIE   (7U)          //!< Bit position for FTFL_FCNFG_CCIE.
#define BM_FTFL_FCNFG_CCIE   (0x80U)       //!< Bit mask for FTFL_FCNFG_CCIE.
#define BS_FTFL_FCNFG_CCIE   (1U)          //!< Bit field size in bits for FTFL_FCNFG_CCIE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FCNFG_CCIE field.
#define BR_FTFL_FCNFG_CCIE   (BITBAND_ACCESS8(HW_FTFL_FCNFG_ADDR, BP_FTFL_FCNFG_CCIE))
#endif

//! @brief Format value for bitfield FTFL_FCNFG_CCIE.
#define BF_FTFL_FCNFG_CCIE(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FCNFG_CCIE), uint8_t) & BM_FTFL_FCNFG_CCIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CCIE field to a new value.
#define BW_FTFL_FCNFG_CCIE(v) (BITBAND_ACCESS8(HW_FTFL_FCNFG_ADDR, BP_FTFL_FCNFG_CCIE) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_FTFL_FSEC - Flash Security Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_FTFL_FSEC - Flash Security Register (RO)
 *
 * Reset value: 0x00U
 *
 * This read-only register holds all bits associated with the security of the
 * MCU and FTFL module. During the reset sequence, the register is loaded with the
 * contents of the flash security byte in the Flash Configuration Field located
 * in program flash memory. The Flash basis for the values is signified by X in
 * the reset value.
 */
typedef union _hw_ftfl_fsec
{
    uint8_t U;
    struct _hw_ftfl_fsec_bitfields
    {
        uint8_t SEC : 2;               //!< [1:0] Flash Security
        uint8_t FSLACC : 2;            //!< [3:2] Freescale Failure Analysis Access Code
        uint8_t MEEN : 2;              //!< [5:4] Mass Erase Enable Bits
        uint8_t KEYEN : 2;             //!< [7:6] Backdoor Key Security Enable
    } B;
} hw_ftfl_fsec_t;
#endif

/*!
 * @name Constants and macros for entire FTFL_FSEC register
 */
//@{
#define HW_FTFL_FSEC_ADDR        (REGS_FTFL_BASE + 0x2U)

#ifndef __LANGUAGE_ASM__
#define HW_FTFL_FSEC             (*(__I hw_ftfl_fsec_t *) HW_FTFL_FSEC_ADDR)
#define HW_FTFL_FSEC_RD()        (HW_FTFL_FSEC.U)
#endif
//@}

/*
 * Constants & macros for individual FTFL_FSEC bitfields
 */

/*!
 * @name Register FTFL_FSEC, field SEC[1:0] (RO)
 *
 * These bits define the security state of the MCU. In the secure state, the MCU
 * limits access to FTFL module resources. The limitations are defined per
 * device and are detailed in the Chip Configuration details. If the FTFL module is
 * unsecured using backdoor key access, the SEC bits are forced to 10b.
 *
 * Values:
 * - 00 - MCU security status is secure
 * - 01 - MCU security status is secure
 * - 10 - MCU security status is unsecure (The standard shipping condition of
 *     the FTFL is unsecure.)
 * - 11 - MCU security status is secure
 */
//@{
#define BP_FTFL_FSEC_SEC     (0U)          //!< Bit position for FTFL_FSEC_SEC.
#define BM_FTFL_FSEC_SEC     (0x03U)       //!< Bit mask for FTFL_FSEC_SEC.
#define BS_FTFL_FSEC_SEC     (2U)          //!< Bit field size in bits for FTFL_FSEC_SEC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FSEC_SEC field.
#define BR_FTFL_FSEC_SEC     (HW_FTFL_FSEC.B.SEC)
#endif
//@}

/*!
 * @name Register FTFL_FSEC, field FSLACC[3:2] (RO)
 *
 * These bits enable or disable access to the flash memory contents during
 * returned part failure analysis at Freescale. When SEC is secure and FSLACC is
 * denied, access to the program flash contents is denied and any failure analysis
 * performed by Freescale factory test must begin with a full erase to unsecure the
 * part. When access is granted (SEC is unsecure, or SEC is secure and FSLACC is
 * granted), Freescale factory testing has visibility of the current flash
 * contents. The state of the FSLACC bits is only relevant when the SEC bits are set to
 * secure. When the SEC field is set to unsecure, the FSLACC setting does not
 * matter.
 *
 * Values:
 * - 00 - Freescale factory access granted
 * - 01 - Freescale factory access denied
 * - 10 - Freescale factory access denied
 * - 11 - Freescale factory access granted
 */
//@{
#define BP_FTFL_FSEC_FSLACC  (2U)          //!< Bit position for FTFL_FSEC_FSLACC.
#define BM_FTFL_FSEC_FSLACC  (0x0CU)       //!< Bit mask for FTFL_FSEC_FSLACC.
#define BS_FTFL_FSEC_FSLACC  (2U)          //!< Bit field size in bits for FTFL_FSEC_FSLACC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FSEC_FSLACC field.
#define BR_FTFL_FSEC_FSLACC  (HW_FTFL_FSEC.B.FSLACC)
#endif
//@}

/*!
 * @name Register FTFL_FSEC, field MEEN[5:4] (RO)
 *
 * Enables and disables mass erase capability of the FTFL module. The state of
 * the MEEN bits is only relevant when the SEC bits are set to secure outside of
 * NVM Normal Mode. When the SEC field is set to unsecure, the MEEN setting does
 * not matter.
 *
 * Values:
 * - 00 - Mass erase is enabled
 * - 01 - Mass erase is enabled
 * - 10 - Mass erase is disabled
 * - 11 - Mass erase is enabled
 */
//@{
#define BP_FTFL_FSEC_MEEN    (4U)          //!< Bit position for FTFL_FSEC_MEEN.
#define BM_FTFL_FSEC_MEEN    (0x30U)       //!< Bit mask for FTFL_FSEC_MEEN.
#define BS_FTFL_FSEC_MEEN    (2U)          //!< Bit field size in bits for FTFL_FSEC_MEEN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FSEC_MEEN field.
#define BR_FTFL_FSEC_MEEN    (HW_FTFL_FSEC.B.MEEN)
#endif
//@}

/*!
 * @name Register FTFL_FSEC, field KEYEN[7:6] (RO)
 *
 * These bits enable and disable backdoor key access to the FTFL module.
 *
 * Values:
 * - 00 - Backdoor key access disabled
 * - 01 - Backdoor key access disabled (preferred KEYEN state to disable
 *     backdoor key access)
 * - 10 - Backdoor key access enabled
 * - 11 - Backdoor key access disabled
 */
//@{
#define BP_FTFL_FSEC_KEYEN   (6U)          //!< Bit position for FTFL_FSEC_KEYEN.
#define BM_FTFL_FSEC_KEYEN   (0xC0U)       //!< Bit mask for FTFL_FSEC_KEYEN.
#define BS_FTFL_FSEC_KEYEN   (2U)          //!< Bit field size in bits for FTFL_FSEC_KEYEN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FSEC_KEYEN field.
#define BR_FTFL_FSEC_KEYEN   (HW_FTFL_FSEC.B.KEYEN)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_FTFL_FOPT - Flash Option Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_FTFL_FOPT - Flash Option Register (RO)
 *
 * Reset value: 0x00U
 *
 * The flash option register allows the MCU to customize its operations by
 * examining the state of these read-only bits, which are loaded from NVM at reset.
 * The function of the bits is defined in the device's Chip Configuration details.
 * All bits in the register are read-only . During the reset sequence, the
 * register is loaded from the flash nonvolatile option byte in the Flash Configuration
 * Field located in program flash memory. The flash basis for the values is
 * signified by X in the reset value.
 */
typedef union _hw_ftfl_fopt
{
    uint8_t U;
    struct _hw_ftfl_fopt_bitfields
    {
        uint8_t OPT : 8;               //!< [7:0] Nonvolatile Option
    } B;
} hw_ftfl_fopt_t;
#endif

/*!
 * @name Constants and macros for entire FTFL_FOPT register
 */
//@{
#define HW_FTFL_FOPT_ADDR        (REGS_FTFL_BASE + 0x3U)

#ifndef __LANGUAGE_ASM__
#define HW_FTFL_FOPT             (*(__I hw_ftfl_fopt_t *) HW_FTFL_FOPT_ADDR)
#define HW_FTFL_FOPT_RD()        (HW_FTFL_FOPT.U)
#endif
//@}

/*
 * Constants & macros for individual FTFL_FOPT bitfields
 */

/*!
 * @name Register FTFL_FOPT, field OPT[7:0] (RO)
 *
 * These bits are loaded from flash to this register at reset. Refer to the
 * device's Chip Configuration details for the definition and use of these bits.
 */
//@{
#define BP_FTFL_FOPT_OPT     (0U)          //!< Bit position for FTFL_FOPT_OPT.
#define BM_FTFL_FOPT_OPT     (0xFFU)       //!< Bit mask for FTFL_FOPT_OPT.
#define BS_FTFL_FOPT_OPT     (8U)          //!< Bit field size in bits for FTFL_FOPT_OPT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FOPT_OPT field.
#define BR_FTFL_FOPT_OPT     (HW_FTFL_FOPT.B.OPT)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_FTFL_FCCOB3 - Flash Common Command Object Registers
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_FTFL_FCCOB3 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfl_fccob3
{
    uint8_t U;
    struct _hw_ftfl_fccob3_bitfields
    {
        uint8_t CCOBn : 8;             //!< [7:0]
    } B;
} hw_ftfl_fccob3_t;
#endif

/*!
 * @name Constants and macros for entire FTFL_FCCOB3 register
 */
//@{
#define HW_FTFL_FCCOB3_ADDR      (REGS_FTFL_BASE + 0x4U)

#ifndef __LANGUAGE_ASM__
#define HW_FTFL_FCCOB3           (*(__IO hw_ftfl_fccob3_t *) HW_FTFL_FCCOB3_ADDR)
#define HW_FTFL_FCCOB3_RD()      (HW_FTFL_FCCOB3.U)
#define HW_FTFL_FCCOB3_WR(v)     (HW_FTFL_FCCOB3.U = (v))
#define HW_FTFL_FCCOB3_SET(v)    (HW_FTFL_FCCOB3_WR(HW_FTFL_FCCOB3_RD() |  (v)))
#define HW_FTFL_FCCOB3_CLR(v)    (HW_FTFL_FCCOB3_WR(HW_FTFL_FCCOB3_RD() & ~(v)))
#define HW_FTFL_FCCOB3_TOG(v)    (HW_FTFL_FCCOB3_WR(HW_FTFL_FCCOB3_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual FTFL_FCCOB3 bitfields
 */

/*!
 * @name Register FTFL_FCCOB3, field CCOBn[7:0] (RW)
 */
//@{
#define BP_FTFL_FCCOB3_CCOBn (0U)          //!< Bit position for FTFL_FCCOB3_CCOBn.
#define BM_FTFL_FCCOB3_CCOBn (0xFFU)       //!< Bit mask for FTFL_FCCOB3_CCOBn.
#define BS_FTFL_FCCOB3_CCOBn (8U)          //!< Bit field size in bits for FTFL_FCCOB3_CCOBn.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FCCOB3_CCOBn field.
#define BR_FTFL_FCCOB3_CCOBn (HW_FTFL_FCCOB3.B.CCOBn)
#endif

//! @brief Format value for bitfield FTFL_FCCOB3_CCOBn.
#define BF_FTFL_FCCOB3_CCOBn(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FCCOB3_CCOBn), uint8_t) & BM_FTFL_FCCOB3_CCOBn)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CCOBn field to a new value.
#define BW_FTFL_FCCOB3_CCOBn(v) (HW_FTFL_FCCOB3_WR((HW_FTFL_FCCOB3_RD() & ~BM_FTFL_FCCOB3_CCOBn) | BF_FTFL_FCCOB3_CCOBn(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_FTFL_FCCOB2 - Flash Common Command Object Registers
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_FTFL_FCCOB2 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfl_fccob2
{
    uint8_t U;
    struct _hw_ftfl_fccob2_bitfields
    {
        uint8_t CCOBn : 8;             //!< [7:0]
    } B;
} hw_ftfl_fccob2_t;
#endif

/*!
 * @name Constants and macros for entire FTFL_FCCOB2 register
 */
//@{
#define HW_FTFL_FCCOB2_ADDR      (REGS_FTFL_BASE + 0x5U)

#ifndef __LANGUAGE_ASM__
#define HW_FTFL_FCCOB2           (*(__IO hw_ftfl_fccob2_t *) HW_FTFL_FCCOB2_ADDR)
#define HW_FTFL_FCCOB2_RD()      (HW_FTFL_FCCOB2.U)
#define HW_FTFL_FCCOB2_WR(v)     (HW_FTFL_FCCOB2.U = (v))
#define HW_FTFL_FCCOB2_SET(v)    (HW_FTFL_FCCOB2_WR(HW_FTFL_FCCOB2_RD() |  (v)))
#define HW_FTFL_FCCOB2_CLR(v)    (HW_FTFL_FCCOB2_WR(HW_FTFL_FCCOB2_RD() & ~(v)))
#define HW_FTFL_FCCOB2_TOG(v)    (HW_FTFL_FCCOB2_WR(HW_FTFL_FCCOB2_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual FTFL_FCCOB2 bitfields
 */

/*!
 * @name Register FTFL_FCCOB2, field CCOBn[7:0] (RW)
 */
//@{
#define BP_FTFL_FCCOB2_CCOBn (0U)          //!< Bit position for FTFL_FCCOB2_CCOBn.
#define BM_FTFL_FCCOB2_CCOBn (0xFFU)       //!< Bit mask for FTFL_FCCOB2_CCOBn.
#define BS_FTFL_FCCOB2_CCOBn (8U)          //!< Bit field size in bits for FTFL_FCCOB2_CCOBn.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FCCOB2_CCOBn field.
#define BR_FTFL_FCCOB2_CCOBn (HW_FTFL_FCCOB2.B.CCOBn)
#endif

//! @brief Format value for bitfield FTFL_FCCOB2_CCOBn.
#define BF_FTFL_FCCOB2_CCOBn(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FCCOB2_CCOBn), uint8_t) & BM_FTFL_FCCOB2_CCOBn)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CCOBn field to a new value.
#define BW_FTFL_FCCOB2_CCOBn(v) (HW_FTFL_FCCOB2_WR((HW_FTFL_FCCOB2_RD() & ~BM_FTFL_FCCOB2_CCOBn) | BF_FTFL_FCCOB2_CCOBn(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_FTFL_FCCOB1 - Flash Common Command Object Registers
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_FTFL_FCCOB1 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfl_fccob1
{
    uint8_t U;
    struct _hw_ftfl_fccob1_bitfields
    {
        uint8_t CCOBn : 8;             //!< [7:0]
    } B;
} hw_ftfl_fccob1_t;
#endif

/*!
 * @name Constants and macros for entire FTFL_FCCOB1 register
 */
//@{
#define HW_FTFL_FCCOB1_ADDR      (REGS_FTFL_BASE + 0x6U)

#ifndef __LANGUAGE_ASM__
#define HW_FTFL_FCCOB1           (*(__IO hw_ftfl_fccob1_t *) HW_FTFL_FCCOB1_ADDR)
#define HW_FTFL_FCCOB1_RD()      (HW_FTFL_FCCOB1.U)
#define HW_FTFL_FCCOB1_WR(v)     (HW_FTFL_FCCOB1.U = (v))
#define HW_FTFL_FCCOB1_SET(v)    (HW_FTFL_FCCOB1_WR(HW_FTFL_FCCOB1_RD() |  (v)))
#define HW_FTFL_FCCOB1_CLR(v)    (HW_FTFL_FCCOB1_WR(HW_FTFL_FCCOB1_RD() & ~(v)))
#define HW_FTFL_FCCOB1_TOG(v)    (HW_FTFL_FCCOB1_WR(HW_FTFL_FCCOB1_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual FTFL_FCCOB1 bitfields
 */

/*!
 * @name Register FTFL_FCCOB1, field CCOBn[7:0] (RW)
 */
//@{
#define BP_FTFL_FCCOB1_CCOBn (0U)          //!< Bit position for FTFL_FCCOB1_CCOBn.
#define BM_FTFL_FCCOB1_CCOBn (0xFFU)       //!< Bit mask for FTFL_FCCOB1_CCOBn.
#define BS_FTFL_FCCOB1_CCOBn (8U)          //!< Bit field size in bits for FTFL_FCCOB1_CCOBn.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FCCOB1_CCOBn field.
#define BR_FTFL_FCCOB1_CCOBn (HW_FTFL_FCCOB1.B.CCOBn)
#endif

//! @brief Format value for bitfield FTFL_FCCOB1_CCOBn.
#define BF_FTFL_FCCOB1_CCOBn(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FCCOB1_CCOBn), uint8_t) & BM_FTFL_FCCOB1_CCOBn)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CCOBn field to a new value.
#define BW_FTFL_FCCOB1_CCOBn(v) (HW_FTFL_FCCOB1_WR((HW_FTFL_FCCOB1_RD() & ~BM_FTFL_FCCOB1_CCOBn) | BF_FTFL_FCCOB1_CCOBn(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_FTFL_FCCOB0 - Flash Common Command Object Registers
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_FTFL_FCCOB0 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfl_fccob0
{
    uint8_t U;
    struct _hw_ftfl_fccob0_bitfields
    {
        uint8_t CCOBn : 8;             //!< [7:0]
    } B;
} hw_ftfl_fccob0_t;
#endif

/*!
 * @name Constants and macros for entire FTFL_FCCOB0 register
 */
//@{
#define HW_FTFL_FCCOB0_ADDR      (REGS_FTFL_BASE + 0x7U)

#ifndef __LANGUAGE_ASM__
#define HW_FTFL_FCCOB0           (*(__IO hw_ftfl_fccob0_t *) HW_FTFL_FCCOB0_ADDR)
#define HW_FTFL_FCCOB0_RD()      (HW_FTFL_FCCOB0.U)
#define HW_FTFL_FCCOB0_WR(v)     (HW_FTFL_FCCOB0.U = (v))
#define HW_FTFL_FCCOB0_SET(v)    (HW_FTFL_FCCOB0_WR(HW_FTFL_FCCOB0_RD() |  (v)))
#define HW_FTFL_FCCOB0_CLR(v)    (HW_FTFL_FCCOB0_WR(HW_FTFL_FCCOB0_RD() & ~(v)))
#define HW_FTFL_FCCOB0_TOG(v)    (HW_FTFL_FCCOB0_WR(HW_FTFL_FCCOB0_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual FTFL_FCCOB0 bitfields
 */

/*!
 * @name Register FTFL_FCCOB0, field CCOBn[7:0] (RW)
 */
//@{
#define BP_FTFL_FCCOB0_CCOBn (0U)          //!< Bit position for FTFL_FCCOB0_CCOBn.
#define BM_FTFL_FCCOB0_CCOBn (0xFFU)       //!< Bit mask for FTFL_FCCOB0_CCOBn.
#define BS_FTFL_FCCOB0_CCOBn (8U)          //!< Bit field size in bits for FTFL_FCCOB0_CCOBn.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FCCOB0_CCOBn field.
#define BR_FTFL_FCCOB0_CCOBn (HW_FTFL_FCCOB0.B.CCOBn)
#endif

//! @brief Format value for bitfield FTFL_FCCOB0_CCOBn.
#define BF_FTFL_FCCOB0_CCOBn(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FCCOB0_CCOBn), uint8_t) & BM_FTFL_FCCOB0_CCOBn)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CCOBn field to a new value.
#define BW_FTFL_FCCOB0_CCOBn(v) (HW_FTFL_FCCOB0_WR((HW_FTFL_FCCOB0_RD() & ~BM_FTFL_FCCOB0_CCOBn) | BF_FTFL_FCCOB0_CCOBn(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_FTFL_FCCOB7 - Flash Common Command Object Registers
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_FTFL_FCCOB7 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfl_fccob7
{
    uint8_t U;
    struct _hw_ftfl_fccob7_bitfields
    {
        uint8_t CCOBn : 8;             //!< [7:0]
    } B;
} hw_ftfl_fccob7_t;
#endif

/*!
 * @name Constants and macros for entire FTFL_FCCOB7 register
 */
//@{
#define HW_FTFL_FCCOB7_ADDR      (REGS_FTFL_BASE + 0x8U)

#ifndef __LANGUAGE_ASM__
#define HW_FTFL_FCCOB7           (*(__IO hw_ftfl_fccob7_t *) HW_FTFL_FCCOB7_ADDR)
#define HW_FTFL_FCCOB7_RD()      (HW_FTFL_FCCOB7.U)
#define HW_FTFL_FCCOB7_WR(v)     (HW_FTFL_FCCOB7.U = (v))
#define HW_FTFL_FCCOB7_SET(v)    (HW_FTFL_FCCOB7_WR(HW_FTFL_FCCOB7_RD() |  (v)))
#define HW_FTFL_FCCOB7_CLR(v)    (HW_FTFL_FCCOB7_WR(HW_FTFL_FCCOB7_RD() & ~(v)))
#define HW_FTFL_FCCOB7_TOG(v)    (HW_FTFL_FCCOB7_WR(HW_FTFL_FCCOB7_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual FTFL_FCCOB7 bitfields
 */

/*!
 * @name Register FTFL_FCCOB7, field CCOBn[7:0] (RW)
 */
//@{
#define BP_FTFL_FCCOB7_CCOBn (0U)          //!< Bit position for FTFL_FCCOB7_CCOBn.
#define BM_FTFL_FCCOB7_CCOBn (0xFFU)       //!< Bit mask for FTFL_FCCOB7_CCOBn.
#define BS_FTFL_FCCOB7_CCOBn (8U)          //!< Bit field size in bits for FTFL_FCCOB7_CCOBn.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FCCOB7_CCOBn field.
#define BR_FTFL_FCCOB7_CCOBn (HW_FTFL_FCCOB7.B.CCOBn)
#endif

//! @brief Format value for bitfield FTFL_FCCOB7_CCOBn.
#define BF_FTFL_FCCOB7_CCOBn(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FCCOB7_CCOBn), uint8_t) & BM_FTFL_FCCOB7_CCOBn)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CCOBn field to a new value.
#define BW_FTFL_FCCOB7_CCOBn(v) (HW_FTFL_FCCOB7_WR((HW_FTFL_FCCOB7_RD() & ~BM_FTFL_FCCOB7_CCOBn) | BF_FTFL_FCCOB7_CCOBn(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_FTFL_FCCOB6 - Flash Common Command Object Registers
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_FTFL_FCCOB6 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfl_fccob6
{
    uint8_t U;
    struct _hw_ftfl_fccob6_bitfields
    {
        uint8_t CCOBn : 8;             //!< [7:0]
    } B;
} hw_ftfl_fccob6_t;
#endif

/*!
 * @name Constants and macros for entire FTFL_FCCOB6 register
 */
//@{
#define HW_FTFL_FCCOB6_ADDR      (REGS_FTFL_BASE + 0x9U)

#ifndef __LANGUAGE_ASM__
#define HW_FTFL_FCCOB6           (*(__IO hw_ftfl_fccob6_t *) HW_FTFL_FCCOB6_ADDR)
#define HW_FTFL_FCCOB6_RD()      (HW_FTFL_FCCOB6.U)
#define HW_FTFL_FCCOB6_WR(v)     (HW_FTFL_FCCOB6.U = (v))
#define HW_FTFL_FCCOB6_SET(v)    (HW_FTFL_FCCOB6_WR(HW_FTFL_FCCOB6_RD() |  (v)))
#define HW_FTFL_FCCOB6_CLR(v)    (HW_FTFL_FCCOB6_WR(HW_FTFL_FCCOB6_RD() & ~(v)))
#define HW_FTFL_FCCOB6_TOG(v)    (HW_FTFL_FCCOB6_WR(HW_FTFL_FCCOB6_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual FTFL_FCCOB6 bitfields
 */

/*!
 * @name Register FTFL_FCCOB6, field CCOBn[7:0] (RW)
 */
//@{
#define BP_FTFL_FCCOB6_CCOBn (0U)          //!< Bit position for FTFL_FCCOB6_CCOBn.
#define BM_FTFL_FCCOB6_CCOBn (0xFFU)       //!< Bit mask for FTFL_FCCOB6_CCOBn.
#define BS_FTFL_FCCOB6_CCOBn (8U)          //!< Bit field size in bits for FTFL_FCCOB6_CCOBn.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FCCOB6_CCOBn field.
#define BR_FTFL_FCCOB6_CCOBn (HW_FTFL_FCCOB6.B.CCOBn)
#endif

//! @brief Format value for bitfield FTFL_FCCOB6_CCOBn.
#define BF_FTFL_FCCOB6_CCOBn(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FCCOB6_CCOBn), uint8_t) & BM_FTFL_FCCOB6_CCOBn)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CCOBn field to a new value.
#define BW_FTFL_FCCOB6_CCOBn(v) (HW_FTFL_FCCOB6_WR((HW_FTFL_FCCOB6_RD() & ~BM_FTFL_FCCOB6_CCOBn) | BF_FTFL_FCCOB6_CCOBn(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_FTFL_FCCOB5 - Flash Common Command Object Registers
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_FTFL_FCCOB5 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfl_fccob5
{
    uint8_t U;
    struct _hw_ftfl_fccob5_bitfields
    {
        uint8_t CCOBn : 8;             //!< [7:0]
    } B;
} hw_ftfl_fccob5_t;
#endif

/*!
 * @name Constants and macros for entire FTFL_FCCOB5 register
 */
//@{
#define HW_FTFL_FCCOB5_ADDR      (REGS_FTFL_BASE + 0xAU)

#ifndef __LANGUAGE_ASM__
#define HW_FTFL_FCCOB5           (*(__IO hw_ftfl_fccob5_t *) HW_FTFL_FCCOB5_ADDR)
#define HW_FTFL_FCCOB5_RD()      (HW_FTFL_FCCOB5.U)
#define HW_FTFL_FCCOB5_WR(v)     (HW_FTFL_FCCOB5.U = (v))
#define HW_FTFL_FCCOB5_SET(v)    (HW_FTFL_FCCOB5_WR(HW_FTFL_FCCOB5_RD() |  (v)))
#define HW_FTFL_FCCOB5_CLR(v)    (HW_FTFL_FCCOB5_WR(HW_FTFL_FCCOB5_RD() & ~(v)))
#define HW_FTFL_FCCOB5_TOG(v)    (HW_FTFL_FCCOB5_WR(HW_FTFL_FCCOB5_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual FTFL_FCCOB5 bitfields
 */

/*!
 * @name Register FTFL_FCCOB5, field CCOBn[7:0] (RW)
 */
//@{
#define BP_FTFL_FCCOB5_CCOBn (0U)          //!< Bit position for FTFL_FCCOB5_CCOBn.
#define BM_FTFL_FCCOB5_CCOBn (0xFFU)       //!< Bit mask for FTFL_FCCOB5_CCOBn.
#define BS_FTFL_FCCOB5_CCOBn (8U)          //!< Bit field size in bits for FTFL_FCCOB5_CCOBn.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FCCOB5_CCOBn field.
#define BR_FTFL_FCCOB5_CCOBn (HW_FTFL_FCCOB5.B.CCOBn)
#endif

//! @brief Format value for bitfield FTFL_FCCOB5_CCOBn.
#define BF_FTFL_FCCOB5_CCOBn(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FCCOB5_CCOBn), uint8_t) & BM_FTFL_FCCOB5_CCOBn)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CCOBn field to a new value.
#define BW_FTFL_FCCOB5_CCOBn(v) (HW_FTFL_FCCOB5_WR((HW_FTFL_FCCOB5_RD() & ~BM_FTFL_FCCOB5_CCOBn) | BF_FTFL_FCCOB5_CCOBn(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_FTFL_FCCOB4 - Flash Common Command Object Registers
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_FTFL_FCCOB4 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfl_fccob4
{
    uint8_t U;
    struct _hw_ftfl_fccob4_bitfields
    {
        uint8_t CCOBn : 8;             //!< [7:0]
    } B;
} hw_ftfl_fccob4_t;
#endif

/*!
 * @name Constants and macros for entire FTFL_FCCOB4 register
 */
//@{
#define HW_FTFL_FCCOB4_ADDR      (REGS_FTFL_BASE + 0xBU)

#ifndef __LANGUAGE_ASM__
#define HW_FTFL_FCCOB4           (*(__IO hw_ftfl_fccob4_t *) HW_FTFL_FCCOB4_ADDR)
#define HW_FTFL_FCCOB4_RD()      (HW_FTFL_FCCOB4.U)
#define HW_FTFL_FCCOB4_WR(v)     (HW_FTFL_FCCOB4.U = (v))
#define HW_FTFL_FCCOB4_SET(v)    (HW_FTFL_FCCOB4_WR(HW_FTFL_FCCOB4_RD() |  (v)))
#define HW_FTFL_FCCOB4_CLR(v)    (HW_FTFL_FCCOB4_WR(HW_FTFL_FCCOB4_RD() & ~(v)))
#define HW_FTFL_FCCOB4_TOG(v)    (HW_FTFL_FCCOB4_WR(HW_FTFL_FCCOB4_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual FTFL_FCCOB4 bitfields
 */

/*!
 * @name Register FTFL_FCCOB4, field CCOBn[7:0] (RW)
 */
//@{
#define BP_FTFL_FCCOB4_CCOBn (0U)          //!< Bit position for FTFL_FCCOB4_CCOBn.
#define BM_FTFL_FCCOB4_CCOBn (0xFFU)       //!< Bit mask for FTFL_FCCOB4_CCOBn.
#define BS_FTFL_FCCOB4_CCOBn (8U)          //!< Bit field size in bits for FTFL_FCCOB4_CCOBn.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FCCOB4_CCOBn field.
#define BR_FTFL_FCCOB4_CCOBn (HW_FTFL_FCCOB4.B.CCOBn)
#endif

//! @brief Format value for bitfield FTFL_FCCOB4_CCOBn.
#define BF_FTFL_FCCOB4_CCOBn(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FCCOB4_CCOBn), uint8_t) & BM_FTFL_FCCOB4_CCOBn)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CCOBn field to a new value.
#define BW_FTFL_FCCOB4_CCOBn(v) (HW_FTFL_FCCOB4_WR((HW_FTFL_FCCOB4_RD() & ~BM_FTFL_FCCOB4_CCOBn) | BF_FTFL_FCCOB4_CCOBn(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_FTFL_FCCOBB - Flash Common Command Object Registers
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_FTFL_FCCOBB - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfl_fccobb
{
    uint8_t U;
    struct _hw_ftfl_fccobb_bitfields
    {
        uint8_t CCOBn : 8;             //!< [7:0]
    } B;
} hw_ftfl_fccobb_t;
#endif

/*!
 * @name Constants and macros for entire FTFL_FCCOBB register
 */
//@{
#define HW_FTFL_FCCOBB_ADDR      (REGS_FTFL_BASE + 0xCU)

#ifndef __LANGUAGE_ASM__
#define HW_FTFL_FCCOBB           (*(__IO hw_ftfl_fccobb_t *) HW_FTFL_FCCOBB_ADDR)
#define HW_FTFL_FCCOBB_RD()      (HW_FTFL_FCCOBB.U)
#define HW_FTFL_FCCOBB_WR(v)     (HW_FTFL_FCCOBB.U = (v))
#define HW_FTFL_FCCOBB_SET(v)    (HW_FTFL_FCCOBB_WR(HW_FTFL_FCCOBB_RD() |  (v)))
#define HW_FTFL_FCCOBB_CLR(v)    (HW_FTFL_FCCOBB_WR(HW_FTFL_FCCOBB_RD() & ~(v)))
#define HW_FTFL_FCCOBB_TOG(v)    (HW_FTFL_FCCOBB_WR(HW_FTFL_FCCOBB_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual FTFL_FCCOBB bitfields
 */

/*!
 * @name Register FTFL_FCCOBB, field CCOBn[7:0] (RW)
 */
//@{
#define BP_FTFL_FCCOBB_CCOBn (0U)          //!< Bit position for FTFL_FCCOBB_CCOBn.
#define BM_FTFL_FCCOBB_CCOBn (0xFFU)       //!< Bit mask for FTFL_FCCOBB_CCOBn.
#define BS_FTFL_FCCOBB_CCOBn (8U)          //!< Bit field size in bits for FTFL_FCCOBB_CCOBn.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FCCOBB_CCOBn field.
#define BR_FTFL_FCCOBB_CCOBn (HW_FTFL_FCCOBB.B.CCOBn)
#endif

//! @brief Format value for bitfield FTFL_FCCOBB_CCOBn.
#define BF_FTFL_FCCOBB_CCOBn(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FCCOBB_CCOBn), uint8_t) & BM_FTFL_FCCOBB_CCOBn)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CCOBn field to a new value.
#define BW_FTFL_FCCOBB_CCOBn(v) (HW_FTFL_FCCOBB_WR((HW_FTFL_FCCOBB_RD() & ~BM_FTFL_FCCOBB_CCOBn) | BF_FTFL_FCCOBB_CCOBn(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_FTFL_FCCOBA - Flash Common Command Object Registers
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_FTFL_FCCOBA - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfl_fccoba
{
    uint8_t U;
    struct _hw_ftfl_fccoba_bitfields
    {
        uint8_t CCOBn : 8;             //!< [7:0]
    } B;
} hw_ftfl_fccoba_t;
#endif

/*!
 * @name Constants and macros for entire FTFL_FCCOBA register
 */
//@{
#define HW_FTFL_FCCOBA_ADDR      (REGS_FTFL_BASE + 0xDU)

#ifndef __LANGUAGE_ASM__
#define HW_FTFL_FCCOBA           (*(__IO hw_ftfl_fccoba_t *) HW_FTFL_FCCOBA_ADDR)
#define HW_FTFL_FCCOBA_RD()      (HW_FTFL_FCCOBA.U)
#define HW_FTFL_FCCOBA_WR(v)     (HW_FTFL_FCCOBA.U = (v))
#define HW_FTFL_FCCOBA_SET(v)    (HW_FTFL_FCCOBA_WR(HW_FTFL_FCCOBA_RD() |  (v)))
#define HW_FTFL_FCCOBA_CLR(v)    (HW_FTFL_FCCOBA_WR(HW_FTFL_FCCOBA_RD() & ~(v)))
#define HW_FTFL_FCCOBA_TOG(v)    (HW_FTFL_FCCOBA_WR(HW_FTFL_FCCOBA_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual FTFL_FCCOBA bitfields
 */

/*!
 * @name Register FTFL_FCCOBA, field CCOBn[7:0] (RW)
 */
//@{
#define BP_FTFL_FCCOBA_CCOBn (0U)          //!< Bit position for FTFL_FCCOBA_CCOBn.
#define BM_FTFL_FCCOBA_CCOBn (0xFFU)       //!< Bit mask for FTFL_FCCOBA_CCOBn.
#define BS_FTFL_FCCOBA_CCOBn (8U)          //!< Bit field size in bits for FTFL_FCCOBA_CCOBn.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FCCOBA_CCOBn field.
#define BR_FTFL_FCCOBA_CCOBn (HW_FTFL_FCCOBA.B.CCOBn)
#endif

//! @brief Format value for bitfield FTFL_FCCOBA_CCOBn.
#define BF_FTFL_FCCOBA_CCOBn(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FCCOBA_CCOBn), uint8_t) & BM_FTFL_FCCOBA_CCOBn)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CCOBn field to a new value.
#define BW_FTFL_FCCOBA_CCOBn(v) (HW_FTFL_FCCOBA_WR((HW_FTFL_FCCOBA_RD() & ~BM_FTFL_FCCOBA_CCOBn) | BF_FTFL_FCCOBA_CCOBn(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_FTFL_FCCOB9 - Flash Common Command Object Registers
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_FTFL_FCCOB9 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfl_fccob9
{
    uint8_t U;
    struct _hw_ftfl_fccob9_bitfields
    {
        uint8_t CCOBn : 8;             //!< [7:0]
    } B;
} hw_ftfl_fccob9_t;
#endif

/*!
 * @name Constants and macros for entire FTFL_FCCOB9 register
 */
//@{
#define HW_FTFL_FCCOB9_ADDR      (REGS_FTFL_BASE + 0xEU)

#ifndef __LANGUAGE_ASM__
#define HW_FTFL_FCCOB9           (*(__IO hw_ftfl_fccob9_t *) HW_FTFL_FCCOB9_ADDR)
#define HW_FTFL_FCCOB9_RD()      (HW_FTFL_FCCOB9.U)
#define HW_FTFL_FCCOB9_WR(v)     (HW_FTFL_FCCOB9.U = (v))
#define HW_FTFL_FCCOB9_SET(v)    (HW_FTFL_FCCOB9_WR(HW_FTFL_FCCOB9_RD() |  (v)))
#define HW_FTFL_FCCOB9_CLR(v)    (HW_FTFL_FCCOB9_WR(HW_FTFL_FCCOB9_RD() & ~(v)))
#define HW_FTFL_FCCOB9_TOG(v)    (HW_FTFL_FCCOB9_WR(HW_FTFL_FCCOB9_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual FTFL_FCCOB9 bitfields
 */

/*!
 * @name Register FTFL_FCCOB9, field CCOBn[7:0] (RW)
 */
//@{
#define BP_FTFL_FCCOB9_CCOBn (0U)          //!< Bit position for FTFL_FCCOB9_CCOBn.
#define BM_FTFL_FCCOB9_CCOBn (0xFFU)       //!< Bit mask for FTFL_FCCOB9_CCOBn.
#define BS_FTFL_FCCOB9_CCOBn (8U)          //!< Bit field size in bits for FTFL_FCCOB9_CCOBn.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FCCOB9_CCOBn field.
#define BR_FTFL_FCCOB9_CCOBn (HW_FTFL_FCCOB9.B.CCOBn)
#endif

//! @brief Format value for bitfield FTFL_FCCOB9_CCOBn.
#define BF_FTFL_FCCOB9_CCOBn(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FCCOB9_CCOBn), uint8_t) & BM_FTFL_FCCOB9_CCOBn)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CCOBn field to a new value.
#define BW_FTFL_FCCOB9_CCOBn(v) (HW_FTFL_FCCOB9_WR((HW_FTFL_FCCOB9_RD() & ~BM_FTFL_FCCOB9_CCOBn) | BF_FTFL_FCCOB9_CCOBn(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_FTFL_FCCOB8 - Flash Common Command Object Registers
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_FTFL_FCCOB8 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfl_fccob8
{
    uint8_t U;
    struct _hw_ftfl_fccob8_bitfields
    {
        uint8_t CCOBn : 8;             //!< [7:0]
    } B;
} hw_ftfl_fccob8_t;
#endif

/*!
 * @name Constants and macros for entire FTFL_FCCOB8 register
 */
//@{
#define HW_FTFL_FCCOB8_ADDR      (REGS_FTFL_BASE + 0xFU)

#ifndef __LANGUAGE_ASM__
#define HW_FTFL_FCCOB8           (*(__IO hw_ftfl_fccob8_t *) HW_FTFL_FCCOB8_ADDR)
#define HW_FTFL_FCCOB8_RD()      (HW_FTFL_FCCOB8.U)
#define HW_FTFL_FCCOB8_WR(v)     (HW_FTFL_FCCOB8.U = (v))
#define HW_FTFL_FCCOB8_SET(v)    (HW_FTFL_FCCOB8_WR(HW_FTFL_FCCOB8_RD() |  (v)))
#define HW_FTFL_FCCOB8_CLR(v)    (HW_FTFL_FCCOB8_WR(HW_FTFL_FCCOB8_RD() & ~(v)))
#define HW_FTFL_FCCOB8_TOG(v)    (HW_FTFL_FCCOB8_WR(HW_FTFL_FCCOB8_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual FTFL_FCCOB8 bitfields
 */

/*!
 * @name Register FTFL_FCCOB8, field CCOBn[7:0] (RW)
 */
//@{
#define BP_FTFL_FCCOB8_CCOBn (0U)          //!< Bit position for FTFL_FCCOB8_CCOBn.
#define BM_FTFL_FCCOB8_CCOBn (0xFFU)       //!< Bit mask for FTFL_FCCOB8_CCOBn.
#define BS_FTFL_FCCOB8_CCOBn (8U)          //!< Bit field size in bits for FTFL_FCCOB8_CCOBn.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FCCOB8_CCOBn field.
#define BR_FTFL_FCCOB8_CCOBn (HW_FTFL_FCCOB8.B.CCOBn)
#endif

//! @brief Format value for bitfield FTFL_FCCOB8_CCOBn.
#define BF_FTFL_FCCOB8_CCOBn(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FCCOB8_CCOBn), uint8_t) & BM_FTFL_FCCOB8_CCOBn)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CCOBn field to a new value.
#define BW_FTFL_FCCOB8_CCOBn(v) (HW_FTFL_FCCOB8_WR((HW_FTFL_FCCOB8_RD() & ~BM_FTFL_FCCOB8_CCOBn) | BF_FTFL_FCCOB8_CCOBn(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_FTFL_FPROT3 - Program Flash Protection Registers
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_FTFL_FPROT3 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which logical program flash regions are protected
 * from program and erase operations. Protected flash regions cannot have their
 * content changed; that is, these regions cannot be programmed and cannot be
 * erased by any FTFL command. Unprotected regions can be changed by program and
 * erase operations. The four FPROT registers allow 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory. The bitfields are defined
 * in each register as follows: Program flash protection register Program flash
 * protection bits FPROT0 PROT[31:24] FPROT1 PROT[23:16] FPROT2 PROT[15:8] FPROT3
 * PROT[7:0] During the reset sequence, the FPROT registers are loaded with the
 * contents of the program flash protection bytes in the Flash Configuration Field
 * as indicated in the following table. Program flash protection register Flash
 * Configuration Field offset address FPROT0 0x0008 FPROT1 0x0009 FPROT2 0x000A
 * FPROT3 0x000B To change the program flash protection that is loaded during the
 * reset sequence, unprotect the sector of program flash memory that contains the
 * Flash Configuration Field. Then, reprogram the program flash protection byte.
 */
typedef union _hw_ftfl_fprot3
{
    uint8_t U;
    struct _hw_ftfl_fprot3_bitfields
    {
        uint8_t PROT : 8;              //!< [7:0] Program Flash Region Protect
    } B;
} hw_ftfl_fprot3_t;
#endif

/*!
 * @name Constants and macros for entire FTFL_FPROT3 register
 */
//@{
#define HW_FTFL_FPROT3_ADDR      (REGS_FTFL_BASE + 0x10U)

#ifndef __LANGUAGE_ASM__
#define HW_FTFL_FPROT3           (*(__IO hw_ftfl_fprot3_t *) HW_FTFL_FPROT3_ADDR)
#define HW_FTFL_FPROT3_RD()      (HW_FTFL_FPROT3.U)
#define HW_FTFL_FPROT3_WR(v)     (HW_FTFL_FPROT3.U = (v))
#define HW_FTFL_FPROT3_SET(v)    (HW_FTFL_FPROT3_WR(HW_FTFL_FPROT3_RD() |  (v)))
#define HW_FTFL_FPROT3_CLR(v)    (HW_FTFL_FPROT3_WR(HW_FTFL_FPROT3_RD() & ~(v)))
#define HW_FTFL_FPROT3_TOG(v)    (HW_FTFL_FPROT3_WR(HW_FTFL_FPROT3_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual FTFL_FPROT3 bitfields
 */

/*!
 * @name Register FTFL_FPROT3, field PROT[7:0] (RW)
 *
 * Values:
 * - 0 - Program flash region is protected.
 * - 1 - Program flash region is not protected
 */
//@{
#define BP_FTFL_FPROT3_PROT  (0U)          //!< Bit position for FTFL_FPROT3_PROT.
#define BM_FTFL_FPROT3_PROT  (0xFFU)       //!< Bit mask for FTFL_FPROT3_PROT.
#define BS_FTFL_FPROT3_PROT  (8U)          //!< Bit field size in bits for FTFL_FPROT3_PROT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FPROT3_PROT field.
#define BR_FTFL_FPROT3_PROT  (HW_FTFL_FPROT3.B.PROT)
#endif

//! @brief Format value for bitfield FTFL_FPROT3_PROT.
#define BF_FTFL_FPROT3_PROT(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FPROT3_PROT), uint8_t) & BM_FTFL_FPROT3_PROT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PROT field to a new value.
#define BW_FTFL_FPROT3_PROT(v) (HW_FTFL_FPROT3_WR((HW_FTFL_FPROT3_RD() & ~BM_FTFL_FPROT3_PROT) | BF_FTFL_FPROT3_PROT(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_FTFL_FPROT2 - Program Flash Protection Registers
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_FTFL_FPROT2 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which logical program flash regions are protected
 * from program and erase operations. Protected flash regions cannot have their
 * content changed; that is, these regions cannot be programmed and cannot be
 * erased by any FTFL command. Unprotected regions can be changed by program and
 * erase operations. The four FPROT registers allow 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory. The bitfields are defined
 * in each register as follows: Program flash protection register Program flash
 * protection bits FPROT0 PROT[31:24] FPROT1 PROT[23:16] FPROT2 PROT[15:8] FPROT3
 * PROT[7:0] During the reset sequence, the FPROT registers are loaded with the
 * contents of the program flash protection bytes in the Flash Configuration Field
 * as indicated in the following table. Program flash protection register Flash
 * Configuration Field offset address FPROT0 0x0008 FPROT1 0x0009 FPROT2 0x000A
 * FPROT3 0x000B To change the program flash protection that is loaded during the
 * reset sequence, unprotect the sector of program flash memory that contains the
 * Flash Configuration Field. Then, reprogram the program flash protection byte.
 */
typedef union _hw_ftfl_fprot2
{
    uint8_t U;
    struct _hw_ftfl_fprot2_bitfields
    {
        uint8_t PROT : 8;              //!< [7:0] Program Flash Region Protect
    } B;
} hw_ftfl_fprot2_t;
#endif

/*!
 * @name Constants and macros for entire FTFL_FPROT2 register
 */
//@{
#define HW_FTFL_FPROT2_ADDR      (REGS_FTFL_BASE + 0x11U)

#ifndef __LANGUAGE_ASM__
#define HW_FTFL_FPROT2           (*(__IO hw_ftfl_fprot2_t *) HW_FTFL_FPROT2_ADDR)
#define HW_FTFL_FPROT2_RD()      (HW_FTFL_FPROT2.U)
#define HW_FTFL_FPROT2_WR(v)     (HW_FTFL_FPROT2.U = (v))
#define HW_FTFL_FPROT2_SET(v)    (HW_FTFL_FPROT2_WR(HW_FTFL_FPROT2_RD() |  (v)))
#define HW_FTFL_FPROT2_CLR(v)    (HW_FTFL_FPROT2_WR(HW_FTFL_FPROT2_RD() & ~(v)))
#define HW_FTFL_FPROT2_TOG(v)    (HW_FTFL_FPROT2_WR(HW_FTFL_FPROT2_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual FTFL_FPROT2 bitfields
 */

/*!
 * @name Register FTFL_FPROT2, field PROT[7:0] (RW)
 *
 * Values:
 * - 0 - Program flash region is protected.
 * - 1 - Program flash region is not protected
 */
//@{
#define BP_FTFL_FPROT2_PROT  (0U)          //!< Bit position for FTFL_FPROT2_PROT.
#define BM_FTFL_FPROT2_PROT  (0xFFU)       //!< Bit mask for FTFL_FPROT2_PROT.
#define BS_FTFL_FPROT2_PROT  (8U)          //!< Bit field size in bits for FTFL_FPROT2_PROT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FPROT2_PROT field.
#define BR_FTFL_FPROT2_PROT  (HW_FTFL_FPROT2.B.PROT)
#endif

//! @brief Format value for bitfield FTFL_FPROT2_PROT.
#define BF_FTFL_FPROT2_PROT(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FPROT2_PROT), uint8_t) & BM_FTFL_FPROT2_PROT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PROT field to a new value.
#define BW_FTFL_FPROT2_PROT(v) (HW_FTFL_FPROT2_WR((HW_FTFL_FPROT2_RD() & ~BM_FTFL_FPROT2_PROT) | BF_FTFL_FPROT2_PROT(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_FTFL_FPROT1 - Program Flash Protection Registers
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_FTFL_FPROT1 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which logical program flash regions are protected
 * from program and erase operations. Protected flash regions cannot have their
 * content changed; that is, these regions cannot be programmed and cannot be
 * erased by any FTFL command. Unprotected regions can be changed by program and
 * erase operations. The four FPROT registers allow 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory. The bitfields are defined
 * in each register as follows: Program flash protection register Program flash
 * protection bits FPROT0 PROT[31:24] FPROT1 PROT[23:16] FPROT2 PROT[15:8] FPROT3
 * PROT[7:0] During the reset sequence, the FPROT registers are loaded with the
 * contents of the program flash protection bytes in the Flash Configuration Field
 * as indicated in the following table. Program flash protection register Flash
 * Configuration Field offset address FPROT0 0x0008 FPROT1 0x0009 FPROT2 0x000A
 * FPROT3 0x000B To change the program flash protection that is loaded during the
 * reset sequence, unprotect the sector of program flash memory that contains the
 * Flash Configuration Field. Then, reprogram the program flash protection byte.
 */
typedef union _hw_ftfl_fprot1
{
    uint8_t U;
    struct _hw_ftfl_fprot1_bitfields
    {
        uint8_t PROT : 8;              //!< [7:0] Program Flash Region Protect
    } B;
} hw_ftfl_fprot1_t;
#endif

/*!
 * @name Constants and macros for entire FTFL_FPROT1 register
 */
//@{
#define HW_FTFL_FPROT1_ADDR      (REGS_FTFL_BASE + 0x12U)

#ifndef __LANGUAGE_ASM__
#define HW_FTFL_FPROT1           (*(__IO hw_ftfl_fprot1_t *) HW_FTFL_FPROT1_ADDR)
#define HW_FTFL_FPROT1_RD()      (HW_FTFL_FPROT1.U)
#define HW_FTFL_FPROT1_WR(v)     (HW_FTFL_FPROT1.U = (v))
#define HW_FTFL_FPROT1_SET(v)    (HW_FTFL_FPROT1_WR(HW_FTFL_FPROT1_RD() |  (v)))
#define HW_FTFL_FPROT1_CLR(v)    (HW_FTFL_FPROT1_WR(HW_FTFL_FPROT1_RD() & ~(v)))
#define HW_FTFL_FPROT1_TOG(v)    (HW_FTFL_FPROT1_WR(HW_FTFL_FPROT1_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual FTFL_FPROT1 bitfields
 */

/*!
 * @name Register FTFL_FPROT1, field PROT[7:0] (RW)
 *
 * Values:
 * - 0 - Program flash region is protected.
 * - 1 - Program flash region is not protected
 */
//@{
#define BP_FTFL_FPROT1_PROT  (0U)          //!< Bit position for FTFL_FPROT1_PROT.
#define BM_FTFL_FPROT1_PROT  (0xFFU)       //!< Bit mask for FTFL_FPROT1_PROT.
#define BS_FTFL_FPROT1_PROT  (8U)          //!< Bit field size in bits for FTFL_FPROT1_PROT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FPROT1_PROT field.
#define BR_FTFL_FPROT1_PROT  (HW_FTFL_FPROT1.B.PROT)
#endif

//! @brief Format value for bitfield FTFL_FPROT1_PROT.
#define BF_FTFL_FPROT1_PROT(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FPROT1_PROT), uint8_t) & BM_FTFL_FPROT1_PROT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PROT field to a new value.
#define BW_FTFL_FPROT1_PROT(v) (HW_FTFL_FPROT1_WR((HW_FTFL_FPROT1_RD() & ~BM_FTFL_FPROT1_PROT) | BF_FTFL_FPROT1_PROT(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_FTFL_FPROT0 - Program Flash Protection Registers
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_FTFL_FPROT0 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which logical program flash regions are protected
 * from program and erase operations. Protected flash regions cannot have their
 * content changed; that is, these regions cannot be programmed and cannot be
 * erased by any FTFL command. Unprotected regions can be changed by program and
 * erase operations. The four FPROT registers allow 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory. The bitfields are defined
 * in each register as follows: Program flash protection register Program flash
 * protection bits FPROT0 PROT[31:24] FPROT1 PROT[23:16] FPROT2 PROT[15:8] FPROT3
 * PROT[7:0] During the reset sequence, the FPROT registers are loaded with the
 * contents of the program flash protection bytes in the Flash Configuration Field
 * as indicated in the following table. Program flash protection register Flash
 * Configuration Field offset address FPROT0 0x0008 FPROT1 0x0009 FPROT2 0x000A
 * FPROT3 0x000B To change the program flash protection that is loaded during the
 * reset sequence, unprotect the sector of program flash memory that contains the
 * Flash Configuration Field. Then, reprogram the program flash protection byte.
 */
typedef union _hw_ftfl_fprot0
{
    uint8_t U;
    struct _hw_ftfl_fprot0_bitfields
    {
        uint8_t PROT : 8;              //!< [7:0] Program Flash Region Protect
    } B;
} hw_ftfl_fprot0_t;
#endif

/*!
 * @name Constants and macros for entire FTFL_FPROT0 register
 */
//@{
#define HW_FTFL_FPROT0_ADDR      (REGS_FTFL_BASE + 0x13U)

#ifndef __LANGUAGE_ASM__
#define HW_FTFL_FPROT0           (*(__IO hw_ftfl_fprot0_t *) HW_FTFL_FPROT0_ADDR)
#define HW_FTFL_FPROT0_RD()      (HW_FTFL_FPROT0.U)
#define HW_FTFL_FPROT0_WR(v)     (HW_FTFL_FPROT0.U = (v))
#define HW_FTFL_FPROT0_SET(v)    (HW_FTFL_FPROT0_WR(HW_FTFL_FPROT0_RD() |  (v)))
#define HW_FTFL_FPROT0_CLR(v)    (HW_FTFL_FPROT0_WR(HW_FTFL_FPROT0_RD() & ~(v)))
#define HW_FTFL_FPROT0_TOG(v)    (HW_FTFL_FPROT0_WR(HW_FTFL_FPROT0_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual FTFL_FPROT0 bitfields
 */

/*!
 * @name Register FTFL_FPROT0, field PROT[7:0] (RW)
 *
 * Values:
 * - 0 - Program flash region is protected.
 * - 1 - Program flash region is not protected
 */
//@{
#define BP_FTFL_FPROT0_PROT  (0U)          //!< Bit position for FTFL_FPROT0_PROT.
#define BM_FTFL_FPROT0_PROT  (0xFFU)       //!< Bit mask for FTFL_FPROT0_PROT.
#define BS_FTFL_FPROT0_PROT  (8U)          //!< Bit field size in bits for FTFL_FPROT0_PROT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FPROT0_PROT field.
#define BR_FTFL_FPROT0_PROT  (HW_FTFL_FPROT0.B.PROT)
#endif

//! @brief Format value for bitfield FTFL_FPROT0_PROT.
#define BF_FTFL_FPROT0_PROT(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FPROT0_PROT), uint8_t) & BM_FTFL_FPROT0_PROT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PROT field to a new value.
#define BW_FTFL_FPROT0_PROT(v) (HW_FTFL_FPROT0_WR((HW_FTFL_FPROT0_RD() & ~BM_FTFL_FPROT0_PROT) | BF_FTFL_FPROT0_PROT(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_FTFL_FEPROT - EEPROM Protection Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_FTFL_FEPROT - EEPROM Protection Register (RW)
 *
 * Reset value: 0x00U
 *
 * The FEPROT register defines which EEPROM regions of the FlexRAM are protected
 * against program and erase operations. Protected EEPROM regions cannot have
 * their content changed by writing to it. Unprotected regions can be changed by
 * writing to the FlexRAM.
 */
typedef union _hw_ftfl_feprot
{
    uint8_t U;
    struct _hw_ftfl_feprot_bitfields
    {
        uint8_t EPROT : 8;             //!< [7:0] EEPROM Region Protect
    } B;
} hw_ftfl_feprot_t;
#endif

/*!
 * @name Constants and macros for entire FTFL_FEPROT register
 */
//@{
#define HW_FTFL_FEPROT_ADDR      (REGS_FTFL_BASE + 0x16U)

#ifndef __LANGUAGE_ASM__
#define HW_FTFL_FEPROT           (*(__IO hw_ftfl_feprot_t *) HW_FTFL_FEPROT_ADDR)
#define HW_FTFL_FEPROT_RD()      (HW_FTFL_FEPROT.U)
#define HW_FTFL_FEPROT_WR(v)     (HW_FTFL_FEPROT.U = (v))
#define HW_FTFL_FEPROT_SET(v)    (HW_FTFL_FEPROT_WR(HW_FTFL_FEPROT_RD() |  (v)))
#define HW_FTFL_FEPROT_CLR(v)    (HW_FTFL_FEPROT_WR(HW_FTFL_FEPROT_RD() & ~(v)))
#define HW_FTFL_FEPROT_TOG(v)    (HW_FTFL_FEPROT_WR(HW_FTFL_FEPROT_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual FTFL_FEPROT bitfields
 */

/*!
 * @name Register FTFL_FEPROT, field EPROT[7:0] (RW)
 *
 * Individual EEPROM regions can be protected from alteration by setting the
 * associated EPROT bit. The EPROT bits are not used when the FlexNVM Partition Code
 * is set to data flash only. When the FlexNVM Partition Code is set to data
 * flash and EEPROM or EEPROM only, each EPROT bit covers one-eighth of the
 * configured EEPROM data (see the EEPROM Data Set Size parameter description). In NVM
 * Normal mode: The protection can only be increased. This means that
 * currently-unprotected memory can be protected, but currently-protected memory cannot be
 * unprotected. Since unprotected regions are marked with a 1 and protected regions
 * use a 0, only writes changing 1s to 0s are accepted. This 1-to-0 transition
 * check is performed on a bit-by-bit basis. Those FEPROT bits with 1-to-0
 * transitions are accepted while all bits with 0-to-1 transitions are ignored . In NVM
 * Special mode : All bits of the FEPROT register are writable without
 * restriction. Unprotected areas can be protected and protected areas can be unprotected.
 * Never write to the FEPROT register while a command is running (CCIF=0). Reset:
 * During the reset sequence, the FEPROT register is loaded with the contents of
 * the FlexRAM protection byte in the Flash Configuration Field located in
 * program flash. The flash basis for the reset values is signified by X in the
 * register diagram. To change the EEPROM protection that will be loaded during the
 * reset sequence, the sector of program flash that contains the Flash Configuration
 * Field must be unprotected; then the EEPROM protection byte must be erased and
 * reprogrammed. Trying to alter data by writing to any protected area in the
 * EEPROM results in a protection violation error and sets the FPVIOL bit in the
 * FSTAT register.
 *
 * Values:
 * - 0 - EEPROM region is protected
 * - 1 - EEPROM region is not protected
 */
//@{
#define BP_FTFL_FEPROT_EPROT (0U)          //!< Bit position for FTFL_FEPROT_EPROT.
#define BM_FTFL_FEPROT_EPROT (0xFFU)       //!< Bit mask for FTFL_FEPROT_EPROT.
#define BS_FTFL_FEPROT_EPROT (8U)          //!< Bit field size in bits for FTFL_FEPROT_EPROT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FEPROT_EPROT field.
#define BR_FTFL_FEPROT_EPROT (HW_FTFL_FEPROT.B.EPROT)
#endif

//! @brief Format value for bitfield FTFL_FEPROT_EPROT.
#define BF_FTFL_FEPROT_EPROT(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FEPROT_EPROT), uint8_t) & BM_FTFL_FEPROT_EPROT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EPROT field to a new value.
#define BW_FTFL_FEPROT_EPROT(v) (HW_FTFL_FEPROT_WR((HW_FTFL_FEPROT_RD() & ~BM_FTFL_FEPROT_EPROT) | BF_FTFL_FEPROT_EPROT(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_FTFL_FDPROT - Data Flash Protection Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_FTFL_FDPROT - Data Flash Protection Register (RW)
 *
 * Reset value: 0x00U
 *
 * The FDPROT register defines which data flash regions are protected against
 * program and erase operations. Protected Flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any FTFL command. Unprotected regions can be changed by both program and erase
 * operations.
 */
typedef union _hw_ftfl_fdprot
{
    uint8_t U;
    struct _hw_ftfl_fdprot_bitfields
    {
        uint8_t DPROT : 8;             //!< [7:0] Data Flash Region Protect
    } B;
} hw_ftfl_fdprot_t;
#endif

/*!
 * @name Constants and macros for entire FTFL_FDPROT register
 */
//@{
#define HW_FTFL_FDPROT_ADDR      (REGS_FTFL_BASE + 0x17U)

#ifndef __LANGUAGE_ASM__
#define HW_FTFL_FDPROT           (*(__IO hw_ftfl_fdprot_t *) HW_FTFL_FDPROT_ADDR)
#define HW_FTFL_FDPROT_RD()      (HW_FTFL_FDPROT.U)
#define HW_FTFL_FDPROT_WR(v)     (HW_FTFL_FDPROT.U = (v))
#define HW_FTFL_FDPROT_SET(v)    (HW_FTFL_FDPROT_WR(HW_FTFL_FDPROT_RD() |  (v)))
#define HW_FTFL_FDPROT_CLR(v)    (HW_FTFL_FDPROT_WR(HW_FTFL_FDPROT_RD() & ~(v)))
#define HW_FTFL_FDPROT_TOG(v)    (HW_FTFL_FDPROT_WR(HW_FTFL_FDPROT_RD() ^  (v)))
#endif
//@}

/*
 * Constants & macros for individual FTFL_FDPROT bitfields
 */

/*!
 * @name Register FTFL_FDPROT, field DPROT[7:0] (RW)
 *
 * Individual data flash regions can be protected from program and erase
 * operations by setting the associated DPROT bit. Each DPROT bit protects one-eighth of
 * the partitioned data flash memory space. The granularity of data flash
 * protection cannot be less than the data flash sector size. If an unused DPROT bit is
 * set, the Erase all Blocks command does not execute and the FSTAT[FPVIOL] flag
 * is set. In NVM Normal mode: The protection can only be increased, meaning
 * that currently unprotected memory can be protected but currently protected memory
 * cannot be unprotected. Since unprotected regions are marked with a 1 and
 * protected regions use a 0, only writes changing 1s to 0s are accepted. This 1-to-0
 * transition check is performed on a bit-by-bit basis. Those FDPROT bits with
 * 1-to-0 transitions are accepted while all bits with 0-to-1 transitions are
 * ignored . In NVM Special mode: All bits of the FDPROT register are writable
 * without restriction. Unprotected areas can be protected and protected areas can be
 * unprotected. The user must never write to the FDPROT register while a command
 * is running (CCIF=0). Reset: During the reset sequence, the FDPROT register is
 * loaded with the contents of the data flash protection byte in the Flash
 * Configuration Field located in program flash memory. The flash basis for the reset
 * values is signified by X in the register diagram. To change the data flash
 * protection that will be loaded during the reset sequence, unprotect the sector of
 * program flash that contains the Flash Configuration Field. Then, erase and
 * reprogram the data flash protection byte. Trying to alter data with the program
 * and erase commands in any protected area in the data flash memory results in a
 * protection violation error and sets the FSTAT[FPVIOL] bit. A full block erase
 * of the data flash memory (see the Erase Flash Block command description) is not
 * possible if the data flash memory contains any protected region or if the
 * FlexNVM block has been partitioned for EEPROM.
 *
 * Values:
 * - 0 - Data Flash region is protected
 * - 1 - Data Flash region is not protected
 */
//@{
#define BP_FTFL_FDPROT_DPROT (0U)          //!< Bit position for FTFL_FDPROT_DPROT.
#define BM_FTFL_FDPROT_DPROT (0xFFU)       //!< Bit mask for FTFL_FDPROT_DPROT.
#define BS_FTFL_FDPROT_DPROT (8U)          //!< Bit field size in bits for FTFL_FDPROT_DPROT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the FTFL_FDPROT_DPROT field.
#define BR_FTFL_FDPROT_DPROT (HW_FTFL_FDPROT.B.DPROT)
#endif

//! @brief Format value for bitfield FTFL_FDPROT_DPROT.
#define BF_FTFL_FDPROT_DPROT(v) (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_FTFL_FDPROT_DPROT), uint8_t) & BM_FTFL_FDPROT_DPROT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPROT field to a new value.
#define BW_FTFL_FDPROT_DPROT(v) (HW_FTFL_FDPROT_WR((HW_FTFL_FDPROT_RD() & ~BM_FTFL_FDPROT_DPROT) | BF_FTFL_FDPROT_DPROT(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// hw_ftfl_t - module struct
//-------------------------------------------------------------------------------------------
/*!
 * @brief All FTFL module registers.
 */
#ifndef __LANGUAGE_ASM__
#pragma pack(1)
typedef struct _hw_ftfl
{
    __IO hw_ftfl_fstat_t FSTAT;            //!< [0x0] Flash Status Register
    __IO hw_ftfl_fcnfg_t FCNFG;            //!< [0x1] Flash Configuration Register
    __I hw_ftfl_fsec_t FSEC;               //!< [0x2] Flash Security Register
    __I hw_ftfl_fopt_t FOPT;               //!< [0x3] Flash Option Register
    __IO hw_ftfl_fccob3_t FCCOB3;          //!< [0x4] Flash Common Command Object Registers
    __IO hw_ftfl_fccob2_t FCCOB2;          //!< [0x5] Flash Common Command Object Registers
    __IO hw_ftfl_fccob1_t FCCOB1;          //!< [0x6] Flash Common Command Object Registers
    __IO hw_ftfl_fccob0_t FCCOB0;          //!< [0x7] Flash Common Command Object Registers
    __IO hw_ftfl_fccob7_t FCCOB7;          //!< [0x8] Flash Common Command Object Registers
    __IO hw_ftfl_fccob6_t FCCOB6;          //!< [0x9] Flash Common Command Object Registers
    __IO hw_ftfl_fccob5_t FCCOB5;          //!< [0xA] Flash Common Command Object Registers
    __IO hw_ftfl_fccob4_t FCCOB4;          //!< [0xB] Flash Common Command Object Registers
    __IO hw_ftfl_fccobb_t FCCOBB;          //!< [0xC] Flash Common Command Object Registers
    __IO hw_ftfl_fccoba_t FCCOBA;          //!< [0xD] Flash Common Command Object Registers
    __IO hw_ftfl_fccob9_t FCCOB9;          //!< [0xE] Flash Common Command Object Registers
    __IO hw_ftfl_fccob8_t FCCOB8;          //!< [0xF] Flash Common Command Object Registers
    __IO hw_ftfl_fprot3_t FPROT3;          //!< [0x10] Program Flash Protection Registers
    __IO hw_ftfl_fprot2_t FPROT2;          //!< [0x11] Program Flash Protection Registers
    __IO hw_ftfl_fprot1_t FPROT1;          //!< [0x12] Program Flash Protection Registers
    __IO hw_ftfl_fprot0_t FPROT0;          //!< [0x13] Program Flash Protection Registers
    uint8_t _reserved0[2];
    __IO hw_ftfl_feprot_t FEPROT;          //!< [0x16] EEPROM Protection Register
    __IO hw_ftfl_fdprot_t FDPROT;          //!< [0x17] Data Flash Protection Register
} hw_ftfl_t;
#pragma pack()

//! @brief Macro to access all FTFL registers.
//! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
//!     use the '&' operator, like <code>&HW_FTFL</code>.
#define HW_FTFL        (*(hw_ftfl_t *) REGS_FTFL_BASE)
#endif

#endif // __HW_FTFL_REGISTERS_H__
// v22/130726/0.9
// EOF
